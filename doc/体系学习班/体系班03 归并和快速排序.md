# 归并排序

## 定义

1. 整体是递归，左边排好序+右边排好序+merge让整体有序

2. 让其整体有序的过程里用了排外序方法

3. 可以用非递归实现

## 复杂度

T(N) = 2*T(N/2) + O(N^1)

根据master可知时间复杂度为O(N*logN)

merge过程需要辅助数组，所以额外空间复杂度为O(N)

归并排序的实质是把比较行为变成了有序信息并传递，两个不同的数只比较1次, 比O(N^2)的排序快

## 面试题

题目1: 在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。**求数组小和**。

- 例子： [1,3,4,2,5]
- 1左边比1小的数：没有
- 3左边比3小的数：1
- 4左边比4小的数：1、3
- 2左边比2小的数：1
- 5左边比5小的数：1、3、4、 2
- 所以数组的小和为1+1+3+1+1+3+4+2=16 

题目2：在一个数组中，任何一个前面的数a，和任何一个后面的数b，如果(a,b)是降序的，就称为**逆序对**，返回数组中所有的逆序对。

题目3：在一个数组中，对于每个数num，求有多少个后面的数 * 2 依然<num，求总个数。

- 比如：[3,1,7,0,2]
- 3的后面有：1，0
- 1的后面有：0
- 7的后面有：0，2
- 0的后面没有C
- 2的后面没有
- 所以总共有5个

题目4：给定一个数组arr，两个整数lower和upper，返回arr中有多少个子数组的累加和在[lower,upper]范围上

- https://leetcode.com/problems/count-of-range-sum/

- Sum[i-j]= Sum[j] - Sum[i-1];  

- 求:Sum[i-j] 在[lower,upper] 范围上, Sum[j]=X, 等同于,去求Sum[i-1]在[X-Upper, X-Lower]上

- 以子数组的结尾来划分子f数组

  假设0~i 整体的累加和是X, 求必须以i位置结尾的子数组, 有多少个在[Lower, Upper]范围上.

  等同于,去求以i位置结尾的前缀和中, 有多少个在[X-Upper, X-Lower]上.

- 递归尝试模型：从左到右的尝试。

  更改归并算法，数组范围分成左右两个部分，分别进行查找，最后进行合并时判断。

  在右组中每一个数N, 在左组中是否有在[N-Upper, N-Lower]上的数.

**重点**

归元扩展:  都是在merge过程中,关于左组上的数, 有多少个在右组上达标的, 或是关于右组上的数, 有多少个在左组上达标的

# 快速排序

## 数据分区

题目1：Partition过程

- 给定一个数组arr，和一个整数num。请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。

- 要求额外空间复杂度O(1)，时间复杂度O(N) 


题目2: [[荷兰国旗问题 1]]

1. 给定一个数组arr，和一个整数num。请把小于num的数放在数组的左边，等于num的数放在中间，大于num的数放在数组的右边。
2. 要求额外空间复杂度O(1)，时间复杂度O(N) 

**分两个区**

```text
在arr[L..R]范围上，进行快速排序的过程：

1）用arr[R]对该范围做partition，<= arr[R]的数在左部分并且保证arr[R]最后来到左部分
    的最后一个位置，记为M； <= arr[R]的数在右部分（arr[M+1..R]）
2）对arr[L..M-1]进行快速排序(递归)
3）对arr[M+1..R]进行快速排序(递归)

因为每一次partition都会搞定【一个数】的位置且不会再变动，所以排序能完成
```

**分三个区**

```text
在arr[L..R]范围上，进行快速排序的过程：

1）用arr[R]对该范围做partition，< arr[R]的数在左部分，== arr[R]的数中间，
    >arr[R]的数在右部分。假设== arr[R]的数所在范围是[a,b]
2）对arr[L..a-1]进行快速排序(递归)
3）对arr[b+1..R]进行快速排序(递归)

因为每一次partition都会搞定【一批数】的位置且不会再变动，所以排序能完成
```

**时间复杂度分析**

数组已经有序的时候就是复杂度最高的时候，等差数列，时间复杂度O(N^2)

## 随机快排

荷兰国旗技巧优化：随机阙值

```text
在arr[L..R]范围上，进行快速排序的过程：
1）在这个范围上，随机选一个数记为num，
2）用num对该范围做partition，< num的数在左部分，== num的数中间，>num的数在右部分。
   假设== num的数所在范围是[a,b]
3）对arr[L..a-1]进行快速排序(递归)
4）对arr[b+1..R]进行快速排序(递归)

因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成
```

**随机快排的时间复杂度分析**

1）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差, O(N^2) ~ O(N* logN)
2）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件
3）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是1/N
4）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！

时间复杂度O(N* logN)，

额外空间复杂度O(logN)都是这么来的，

1. 最差情况：每次随机选一个数都在末尾，递归N次，每次要生成一个数组，包含分区的左右边界，则为O(N)。
2. 最好情况：每次都是中点的时候，递归logN次，额外复杂度为O(logN).

## 题目

双向链表的随机快速排序
