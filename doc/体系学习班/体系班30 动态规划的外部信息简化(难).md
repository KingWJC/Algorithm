# 动态规划猜法中的外部信息简化

范围上的尝试，需要范围之外的外部信息。如何简化。

## 题目

### 打气球的最大分数

给定一个数组 arr，代表一排有分数的气球。每打爆一个气球都能获得分数，假设打爆气 球 的分数为 X，获得分数的规则如下: 

1. 如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R。 获得分数为 L*X*R。 
2. 如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 L;如果被打爆气球的右边所有气球都已经被打爆。获得分数为 L*X。
3. 如果被打爆气球的左边所有的气球都已经被打爆;如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为 R;如果被打爆气球的右边所有气球都 已经 被打爆。获得分数为 X*R。 
4. 如果被打爆气球的左边和右边所有的气球都已经被打爆。获得分数为 X。

目标是打爆所有气球，获得每次打爆的分数。通过选择打爆气球的顺序，可以得到不同的总分，请返回能获得的最大分数。

【举例】

arr = {3,2,5} 如果先打爆3，获得3*2;再打爆2，获得2*5;最后打爆5，获得5;最后总分21 

如果先打爆3，获得3*2;再打爆5，获得2*5;最后打爆2，获得2;最后总分18 

如果先打爆2，获得3*2*5;再打爆3，获得3*5;最后打爆5，获得5;最后总分50

*如果先打爆2，获得3*2*5;再打爆5，获得3*5;最后打爆3，获得3;最后总分48

如果先打爆5，获得2*5;再打爆3，获得3*2;最后打爆2，获得2;最后总分18

如果先打爆5，获得2*5;再打爆2，获得3*2;最后打爆3，获得3;最后总分19 返回能获得的最大分数为50

**分析：**

第一次尝试：

1. 进行范围上的尝试：$f(L,R)$，在数组的L到R之间打爆所有气球，选择第一个要打爆的气球，再递归，最终返回最大分数。
2. 但是范围上的尝试，需要用到范围之外的左边没被打爆的气球的位置X，右边没被打爆的气球的位置Y。
3. 可变参数X，Y的让逻辑变得更复杂，所以弃用。

第二次尝试：

1. 进行范围上的尝试：$f(L,R)$，在数组的L到R之间打爆所有气球，选择最后一个被打爆的气球，再递归，最终返回最大分数。
2. 潜台词：每次尝试递归尝试前，必须保证L-1和R+1的气球没有爆炸。
3. 因为选择最后一个被打爆的气球，就可以把数组分为两部分，每部分的L-1和R+1的气球都不会爆炸，所以最大分数计算公式：若最后一个被打爆的气球是1位置，$f(0,5)=f(0,0)+f(2,5)+1*arr[1]*1$。
4. 避免边界检查：扩充原数组，两边增加元素1，表示有分数为1的没有爆的气球。$f(1,5)$.
5. 底层的枚举行为无法用四边形不等式省略。

总结：

1. 问题：为什么要枚举最后打爆的气球而不是最先打爆的气球。
2. 如果题目中获得分数的规则是：当前打爆气球的分数，乘以左边最近爆了的气球，再乘以右边最近爆了的气球，则可以用第一次的尝试方式。枚举最先打爆的气球。
3. 试法的指导原则：如何设计递归函数，让可变参数的类型不要比int类型更加复杂，且参数不多，常见方式：
   1. 设计潜台词：当递归函数满足一定潜台词的情况下，有可能不用管某些需要的外部信息。如第二次试法的潜台词是保证L-1和R+1的气球没有爆炸，可以省下左边信息和右边信息的具体情况。
   2. 从尝试入手：可能性的展开方面用什么分类，枚举最先打爆的气球不行，就试最后。
   3. 潜台词和最后的尝试是联动关系。最后的尝试才能满足潜台词。
4. **不需要引入外部信息，通过修改潜台词来简化外部信息。**

### 移除盒子

给出一些不同颜色的盒子 boxes ，盒子的颜色由不同的正数表示。

你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k >= 1），这样一轮之后你将得到 k * k 个积分。

返回 你能获得的最大积分和 。

示例：boxes = [1,1,1]，最大积分和是9.

链接：https://leetcode.com/problems/remove-boxes/

**分析：**

暴力递归尝试：

1. 范围上的尝试：$f(L,R,K)$，L到R范围上的最大得分，K为L之前与arr[L]相同的个数。

2. 设定潜规则：arr[L]和L左边的K个数相同。

3. 因为最优解就是把相同个数最多的留在最后消除。

4. 每次用L左侧K个与arr[L]相同的数，与L....R之间的值相同的任意位置进行组合，再递归，最优解的情况下，K会不断增大，直到找到所有相同的数，再计算得分。

5. 示例：arr=[3，2，4，3，6]，$f(0,4,0)=>f(0,0,0)+f(1,4,0)表示0个3和0位置的3一起消掉，剩下1-4范围之前有0个2$，

   若第一轮选择和0位置的3合并，则第二轮只能和3位置的3进行组合：$f(1,4,0)=>f(1,2,0)+f(3,4,1)表示1个3和3位置的3一起消掉，剩下1-2范围之前有0个2$，

常数上的优化：

1. 在L....R范围上和arr[L]相同的连续的数，一起消除。开头连续相同的，只枚举最后一个

2. 中间有连续相同的数，只枚举第一个，之后相同不用管。

   示例：[111**1**,2,2,3,**1**11,4]  ，之前有5个1，加重的枚举项，其它都减支。

总结：

1. 外部信息简化的尝试很难，需要靠大量的练习。
2. 牢记的原则：不要让可变参数的复杂程度突破整型。（除非是状态压缩的动态规划）。
3. **引入有外部信息，只有一个k，让外部信息尽量简单。**

### 字符消除游戏

如果一个字符相邻的位置没有相同字符，那么这个位置的字符出现不能被消掉。比如:"ab"，其中a和b都不能被消掉

如果一个字符相邻的位置有相同字符，就可以一起消掉。比如:“abbbc”，中间一串的b是可以被消掉的，

消除之后剩下“ac”。某些字符如果消掉了，剩下的字符认为重新靠在一起

给定一个字符串，你可以决定每一步消除的顺序，目标是请尽可能多的消掉字符，返回最少的剩余字符数量

【举例】

比如："aacca", 如果先消掉最左侧的"aa"，那么将剩下"cca"，然后把"cc"消掉，剩下的"a"将无法再消除，返回1

但是如果先消掉中间的"cc"，那么将剩下"aaa"，最后都消掉就一个字符也不剩了，返回0，这才是最优解。

再比如："baaccabb"，如果先消除最左侧的两个a，剩下"bccabb"，如果再消除最左侧的两个c，剩下"babb"，

最后消除最右侧的两个b，剩下"ba"无法再消除，返回2

而最优策略是：先消除中间的两个c，剩下"baaabb"，再消除中间的三个a，剩下"bbb"，最后消除三个b，

不留下任何字符，返回0，这才是最优解

**分析：**

暴力规划：

1. 和上一题相同，$f(L,R,K)$中K表示L之前的值是否和arr[L]相等。
2. K为false，表示L之前没有数相同，则先求L.....R范围内的前缀，在递归调用。
3. K为ture，表示L之前有数相同，则在L.....R范围上相同值的位置X，如果$f(L+1,X-1,0)=0$表示中间的字符串可以消掉，那么L和X位置的数可以消掉。

### 奇怪的打印机

有台奇怪的打印机有以下两个特殊要求：

- 打印机每次只能打印由 同一个字符 组成的序列。
- 每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。

给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。

链接：https://leetcode.com/problems/strange-printer/

示例：

输入：s = "aba"
输出：2
解释：首先打印 "aaa" 然后在第二个位置打印 "b" 覆盖掉原来的字符 'a'。

**分析：**

暴力递归：

1. $f(L,R)$求在L....R范围上的最少打印次数。

2. L位置的字符，最先打印或最后打印，都不影响最优解的结果。

   因为边缘位置在第一次被打印出来，之后打印时的范围不需要覆盖L位置。

   潜台词：每次打印，先打印第一个位置L。

3. 可能性划分：整个范围可以划分为两部分，枚举所有可能的划分点K  。

   如先打印（L，L）和（L+1，R），或（L，L+1）和（L+2，R）.......

4. 划分的可能性中：如果左部分和右部分有相同的字符，那么一定有一个划分点，可以让左部分的第一个位置，等于右部分第一个位置。左右两部分在最左第一位置相同的字符，可以合并为1次打印。

   兼顾L.....R范围的字符，一次都打印的最优解。


虽然是区域上的划分，但没有四边形不等式的解。只能是O(N^3)

常数优化：可以用最长前缀优化分支。

### 还原数组丢失的数字

整型数组arr长度为n(3 <= n <= 10^4)，最初每个数字是<=200的正数且满足如下条件： 

1. arr[0] <= arr[1]（左边界）

2. arr[n-1] <= arr[n-2]（右边界）

3. arr[i] <= max(arr[i-1], arr[i+1])（中间的数）

但是在arr有些数字丢失了，比如k位置的数字之前是正数，

丢失之后k位置的数字为0。

请你根据上述条件， 计算可能有多少种不同的arr可以满足以上条件。

比如 [6,0,9] 只有还原成 [6,9,9]满足全部三个条件，所以返回1种

比如 [0，0] 可以还原成 [1，1]~[200，200]都满足全部三个条件，所以返回200种

**分析：**

暴力递归：

1. 从右往左的尝试$f(i,V,S)$：将i位置的值改为V，求在0......i范围上的有多少种组合方式。

   S是arr[i]=V后和arr[i+1]的关系，s==0，arr[i] < arr[i+1]；s\==1，arr[i] =\= arr[i+1]；s\==2.....

2. 比如[6，0，0，8]，3位置的数是8不为0，所以V=8，边界外的4位置数不可以大于8，因为边界3位置的数只依赖2位置。若4位置的数大于等于8，通过规则3，则会放宽2位置的范围，所以i+1只能小于8，调用$f(3,8,2)$

   若3位置为0，则V可以从[1，200]范围上枚举。

3. 最重要的是第三个参数的设计，让右侧已经做的决定，且需要当前位置知道的状况，用最精简的方式表示。

时间复杂度：O(N)

1. 动态规划表中：V的范围是1-200，S的范围是0-2，所以是一个600N的表，
2. 而每个位置的枚举范围是固定200范围内，
3. V，S，枚举的变化都是小常数，所以是O(600N)*O(200) => O(N)

优化：

1. 示例：$f(7,90,0)$表示来到7位置，填90，且arr[8]>90.

   $f(7,90,0)=f(6,1-89,0)+f(6,90,1)+f(6,91-200,2)$

   $f(7,90,1)=f(6,1-89,0)+f(6,90,1)+f(6,91-200,2)$

   $f(7,90,2)=f(6,90,1)+f(6,91-200,2)$

   可进行代码上的优化。

2. 用预处理结构（前缀和）来加速区间范围的结果的计算。

   若$f(6,1,0)=5；f(6,2,0)=3；f(6,3,0)=4；f(6,4,0)=2；$

   则状态S为0的前缀和：sum0[1]=5，sum0[2]=8，sum0[3]=12，sum0[4]=14，

   所以当计算$f(i+1,x,x)$的时候，只需要在$f(i,x,x)$过程中，计算出sum0，sum1，sum2前缀和数组。

   用来加速i+1位置的计算。

3. 时间复杂度：O(N)*(O(600)+O(600)) => O(N)
