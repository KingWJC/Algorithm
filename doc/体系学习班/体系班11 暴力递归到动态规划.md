# 暴力递归

暴力递归就是一个简单的递归尝试方法。 出现了一个问题，不知道是怎么解决的，但我们知道可以怎么一步一步进行尝试，在这一步步的尝试过程就可以把问题解决了。

尝试的方法，可以画决策图，也可以用黑盒思维：

1. 把问题转化为规模缩小了的同类问题的子问题
2. 规定**黑盒函数的含义**：包括输入，达到什么效果，遵循的限制条件。

2. 有明确的不需要继续进行递归的条件（base case不需要再分解问题）。

3. 有当得到了子问题的结果之后的决策过程，（如何使用黑盒函数）

4. 不记录每一个子问题的解

## 题目

熟悉什么叫**尝试**：

1. 打印n层汉诺塔从最左边移动到最右边的全部过程

2. 打印一个字符串的全部子序列（可以不连续）

   所有情况是一个二叉树，分支为是否包含当前顶点，如123.  1为顶点，2为1的子节点，3为2的子节点

3. 打印一个字符串的全部子序列，要求不要出现重复字面值的子序列

4. 打印一个字符串的全部排列（字符都要，但顺序不一样）

   深度优先遍历中的技巧：在方法**决策需要原始数据时，恢复现场**。

   两种方法：使用集合 或直接在字符串中交换位置。

5. 打印一个字符串的全部排列，要求不要出现重复的排列

   减支：提前减少分支，boolean[] visit=new boolean[256]

   过滤：Set。

6. 给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数。 如何实现? 

   揭示: 你想怎么试就能怎么写, 但必须保证子问题跟所描述的是一个事，一个大问题要拆成同样含义但数据量变小的子问题  

   但是, 尝试是有优劣的:  比如汉诺塔问题, 可以用6个递归  也可以做抽象化, 变成一个问题 

   重点是: 怎么设计一个尝试, 能够优化出最好版本  

# 动态规划

## 定义

什么暴力递归可以继续优化？

1. 有重复调用同一个子问题的解，这种递归可以优化
2. 如果每一个子问题都是不同的解，无法优化也不用优化

暴力递归和动态规划的关系：

1. 某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划
2. 任何动态规划问题，都一定对应着某一个有重复过程的暴力递归
3. 但不是所有的暴力递归，都一定对应着动态规划

面试题和动态规划的关系：

1. 解决一个问题，可能有很多尝试方法
2. 可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式
3. 一个问题**可能有**若干种动态规划的解法

**暴力递归之所以暴力是因为有大量重复计算在浪费时间**

**动态规划就是某一类尝试行为的进一步优化，任何一个动态规划的问题都是以某一个暴力尝试过程中优化后的样子**

## 步骤

**在递归写法中，找出可变参数， 再找出依赖项，再找出这个动态规划表中我们想要的是哪一块。** 找出不需要依赖其他项的，先填，也就是先填递归到底的情况和边界情况。

![Pasted image 20210504190038](images\Pasted image 20210504190038.png)

### 如何找到某个问题的动态规划方式：

1. 设计暴力递归：**重要原则+4种常见尝试模型**！重点！

   1）从左往右的尝试模型，如背包的bag的**明确的变化范围**。
   	 arr[index......] 从index到结尾，统计结果。

   2）范围上的尝试模型：讨论范围的开头和结尾，结合的可能性（对结果或数据处理的影响）。
   **明确的变化范围**。arr[left.....right]，从left到right，统计结果。

   3）多样本位置全对应的尝试模型：讨论两个样本的结尾结合的可能性。**明确的变化范围**。 
   	arr1[0....i], arr2[0.....j]，统计两个样本在i和j位置的结果。

   4）寻找业务限制的尝试模型：**不能直观的知道可变参数的变化范围**。 如咖啡机问题。
   	  **限制不够，业务来凑。**   arr[index......]，额外业务变量washline，需要计算其变化范围。

2. 分析有没有重复解：

   列出调用过程，可以只列出前几层，有没有重复解，一看便知。

3. 用记忆化搜索 -> 用严格表结构实现动态规划：套路解决

   记忆化搜索：暴力递归中，算过的直接从缓存拿，没算过的继续递归计算，并放入缓存。

   严格依赖表结构：进一步梳理依赖的关系，整理出严格表结构，通过依赖关系，从表的简单位置算出复杂位置，进而求出表中所有值。

   时间复杂度：暴力的复杂度(2个分支就是2^N)，记忆化搜索和动态规划复杂度(就是表大小，在没有枚举行为的情况下同样的好)

4. 看看能否继续优化：动态规划的进一步优化

   1）**空间压缩**：

   没有枚举行为(循环)，每个位置只对有限个临近位置的依赖：如求矩阵中的最小路径和。使用一维数组压缩动态规划表空间。

   2）状态化简：**斜率优化**

   有枚举行为，依赖表中，一个位置需要依赖多个位置（一个for循环），需要做出严格表结构，继续优化。

   3）四边形不等式

   4）其他优化技巧

### 动态规划中的**斜率优化**

1. 利用观察法对枚举行为做斜率优化  把枚举行为省下来
2. 通过观察法: 发现临近的格子对我的枚举行为有加速
3. 当你发现在推每一个格子的时候有枚举行为, 多一点观察,   
4. 观察后可能能发现,你的枚举行为,可以被你的临近位置的值替代,   

当前位置依赖的枚举范围，包含前一位置的所依赖的枚举范围，则当前位置可以取前一位置的结果做参考。

斜率意思，就是枚举范围在表结构中，两位置的依赖的枚举是两条平行的斜线，斜率从[0...180]

### 最优解

有枚举行为，才需要推出严格依赖的表结构，去观察，将枚举行为O(N)改为常数O(1)的依赖关系。

如果没有枚举行为，傻缓存（记忆化搜索）就是最优解。

### **面试**中设计暴力递归过程的重要原则：

1. 每一个可变参数的类型，一定不要比int类型更加复杂，【如可变参数是数组 f(int[] a,int b) ,将a和b的可能性都枚举出来，情况会非常复杂。】
2. 原则1）可以违反，让类型突破到一维线性结构(“aabc"字符串)，那必须是单一可变参数。【f(string a)，突破整形，但只有一个可变参数，可以用傻缓存法，每个结果是一个key】

   如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可。 【如贴纸问题。】
4. 可变参数的个数，能少则少【一个可变参数就是一维表，两个可变参数就是二维表，三个可变参数是三位表】

知道了面试中设计暴力递归过程的原则，然后：

1. 一定要逼自己找到不违反原则情况下的暴力尝试！
2. 如果你找到的暴力尝试，不符合原则，马上舍弃！找新的！
3. 如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%！

### 暴力递归到动态规划的套路

1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用

2）找到哪些参数的变化会影响返回值，对每一个列出变化范围（**寻找递归中的可变参数**）

3）参数间的所有的组合数量，意味着表大小

4）记忆化搜索的方法就是傻缓存，非常容易得到

5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解

6）对于有枚举行为的决策过程，进一步优化

## 题目

### 斐波那契数列

 f(N)=f(N-1)+f(N-2); 求第N项的值，

- 相当于高度N的二叉树，每个节点都返回值，才能得到顶部的值。
- 尝试的暴力递归中有重复过程，可以加缓存进行优化。这个过程就是动态规划。
- 加缓存和顺序计算，时间复杂度都是O(N)。

### 机器人走k步到达p位置的方法

假设有排成一行的N个位置，记为1~N，N 一定大于或等于 2

开始时机器人在其中的M位置上(M 一定是 1~N 中的一个)

如果机器人来到1位置，那么下一步只能往右来到2位置；

如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；

如果机器人来到中间位置，那么下一步可以往左走或者往右走；

规定机器人必须走 K 步，最终能来到P位置(P也是1~N中的一个)的方法有多少种

给定四个参数 N、M、K、P，返回方法数。

**分析**：方法数的数据：是一个有边界条件的二叉树。f(M ,K) = f(M-1 ,K-1) + f(M+1 ,K-1)

尝试：使用暴力递归完成。

优化：M，K能确认一个唯一的结果，所以使用二维缓存表，空间换时间，实现从顶向下的动态规划。

暴力递归中有重复计算，给其加缓存，下回遇到同样一个过程，直接从缓存中拿结果。 也叫**记忆化搜索（动态规划中最糙的一种，不关心状态的依赖）**

**示例**：N: 1~5,  M起始位置: 2，P目标位置: 4，K: 6，填充方法数的二维缓存表

| N位置(行) / K步 (列) |  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :------------------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|        **1**         |  0   |  0   |  0   |  1   |  0   |  4   |  0   |
|        **2**         |  0   |  0   |  1   |  0   |  4   |  0   |  13  |
|        **3**         |  0   |  1   |  0   |  3   |  0   |  9   |  0   |
|        **4**         |  1   |  0   |  2   |  0   |  5   |  0   |  14  |
|        **5**         |  0   |  1   |  0   |  2   |  0   |  5   |  0   |

当剩余步数K为0时，只有到达P: 4，则方法数为1.（base case)，**起始值为第一列**

当当前位置M为1时，只能往位置N: 2的走，总是依赖于下一行2位置的K-1的数据，所以f(1 ,K) = f(2 , K-1)

当当前位置M为5时，只能往位置N: 4的走，总是依赖于上一行2位置的K-1的数据，所以f(5 ,K) = f(4 , K-1)

其它位置：依赖于左下加左上的值。f(M ,K) = f(M-1 ,K-1) + f(M+1 ,K-1)

**结论**

二维动态规划表（状态转移），翻转后是一个会撞墙的杨辉三角形。

动态规划是结果，不是原因。每次的递归尝试，分析位置依赖，尝试的策略就是状态转移的方程。

尝试是自然智慧。是**范围上尝试的模型**。

实现：需要无效参数的总结。

### A,B玩家从左右两边拿纸牌,返回最后获胜者的分数

给定一个整型数组arr，代表数值不同的纸牌排成一条线

玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿

但是每个玩家每次只能拿走最左或最右的纸牌

玩家A和玩家B都绝顶聪明，请返回最后获胜者的分数。 

**分析：**AB同样聪明，每次选择都是最优的决策。

**当前作为先手**，在arr的L到R上拿牌，获得最好分数的**决策**如下：

​		base case L==R  arr[L]直接拿走。

​		若拿走左侧的牌arr[L]，然后轮到后手在L+1到R上，获取最好的分数。

​		若拿走右侧的牌arr[R]，然后轮到后手在L到R-1上，获取最好的分数

​		选择两次结果的最大值返回。

**当前作为后手**：在arr的L到R上拿牌，获得最好分数的**决策**如下：

​		base case L==R  **arr[L]会被B拿走**，只能拿到0。

​		若左侧的牌arr[L]被B拿走，然后轮到先手在L+1到R上，获取最好的分数。

​		若右侧的牌arr[R]被B拿走，然后轮到先手在L到R-1上，获取最好的分数

​		选择两次结果的最小值返回。  因为**B作为先手会把最大的拿走，只会剩下最小的**。

优化1：范围0-7： f(0,7) -> g(1,7)  &  g(0,6) ->  { f(1,6)  &  f(2,7) }  &  { f(1,6)  & f(0,5) }  

​			如上所示， f(1,6) 的计算重复，使用记忆化搜索。 两个二维表，记录先手，后手的分数。

优化2：用严格表结构实现动态规划

**示例**

[50，100，20，10]，只能从左或右选择一张牌

先手：10，100；后手：50，20。 获胜者的分数是110.

[7，4，16，15，1] 的先手，后手，在L到R上的最好分数，的二维动态规划表。

| (先手）L/R | 0    | 1    | 2    | 3    | 4    |
| :--------: | ---- | ---- | ---- | ---- | ---- |
|   **0**    | 7    | 7    | 20   | 23   | 24   |
|   **1**    | X    | 4    | 16   | 19   | 19   |
|   **2**    | X    | X    | 16   | 16   | 17   |
|   **3**    | X    | X    | X    | 15   | 15   |
|   **4**    | X    | X    | X    | X    | 1    |

| （后手）L/R | 0    | 1    | 2    | 3    | 4    |
| :---------: | ---- | ---- | ---- | ---- | ---- |
|    **0**    | 0    | 4    | 7    | 19   | 19   |
|    **1**    | X    | 0    | 4    | 16   | 17   |
|    **2**    | X    | X    | 0    | 15   | 15   |
|    **3**    | X    | X    | X    | 0    | 1    |
|    **4**    | X    | X    | X    | X    | 0    |

1. 对角线表示只剩一张牌，先手的对角线是当前位置的值，后手的对角线是0。 **起始值为对角线**

2. L不能小于R，所以表格下半部分都是X。

3. 按对角线的上一条线，进行填充值。先手表的值需要在后手表中，找对称点，然后L位置的值加上对称点下边的值，R位置的值加上对称点前面的值， 取最大值。

   dpf  = Math.max( arr[L]+dpg\[L+1\]\[R\],  arr[R]+dpg\[L\]\[R-1\] )

   dpg = Math.min( dpf\[L+1\]\[R\],  dpf\[L\]\[R-1\] )

4. **后手的计算，不需要加arr[L]或arr[R], 因为已被对手拿走**

**结论：**

属于**零和博弈**又称“*零和*游戏”，是博弈论的一个概念，属非合作*博弈*，指参*与博弈*的各方，在严格竞争下，一方的收益必然意味着另一方的损失，博弈各方的收益和损失相加总和永远为“零”。

尝试策略和状态转移方程是一回事。

在arr的L到R上尝试，是**范围上尝试的模型**。

### 背包能装下最多的价值

给定两个长度都为N的数组weights和values，

weights[i]和values[i]分别代表 i号物品的重量和价值。

给定一个正数bag，表示一个载重bag的袋子，

你装的物品不能超过这个重量，返回你能装下最多的价值是多少? 

**分析**

1. base case: 当货物重量大于背包重量时，这次的挑选无效。

2. 查找重复操作：可变参数（索引index和背包剩余的重量）

   W：[3，2，5]  V：[7，4，6]  bag=15。 

   P(0,15) -> 选择0和1，不选2，得P(3,10)；  不选择0和1，选择3，得P(3,10).  计算重复。

3. 动态转移方程就是尝试策略。(动态规划是暴力递归的返回值的一个缓存)

**示例**

bag=7,  W：[3，2，5]   V：[7，4，6] 

| **W\bag** | **0** | **1** | **2** | **3** | **4** | **5** | **6** | **7** |
| --------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| **0**     | 0     | 0     | 4     | 7     | 7     | 11    | 11    | 11    |
| **1**     | 0     | 0     | 4     | 4     | 4     | 6     | 6     | 10    |
| **2**     | 0     | 0     | 0     | 0     | 0     | 6     | 6     | 6     |
| **3**     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     |

1. bag剩余量小于0时，返回-1，结果无效，所以不展示。

2. 当W，V的索引为3时，没有货物，所以不管bag的余量还剩多少，都为0。  **起始值为最后一行**

3. 数据从下而上，填充每一行。

   f(0,7) = Math.max ( V[0] + f(1,4)，f(1,7) ).

**结论**

当W，V的索引，从左往右遍历，是**从左往右的尝试模型**。

### 数字转化为字符串的结果数

规定1和A对应、2和B对应、3和C对应...26和Z对应

那么一个数字字符串比如"111”就可以转化为："AAA"、"KA"和"AK"

给定一个只有数字字符组成的字符串str，返回有多少种转化结果 

**分析**

暴力尝试：

1. 使用**从左往右的尝试模型**，
2. 从index位置开始往后转换，index到达数字字符串的边界时，证明有一种转换结果。
3. 可变参数是Index位置。
4. 每次转换有两种方式：转换当前单个字符，转换当前字符和下一个字符。所以数据结构是一个二叉树。
5. 有重复操作：

从左往右的动态规划：**起始值为第一个位置**

1. dp[i]表示：str[i...]有多少种转化方式。
2. 从前往后计算，当前字符是判断字符串的前缀。
3. 只需判断前缀不能为0.  转换有两种方式。依赖dp[i+1]和dp\[i+2]

从右往左的动态规划：**起始值为最后一个位置**

1. dp[i]表示：str[0...i]有多少种转化方式。
2. 从后往前计算，当前字符是判断字符串的后缀。
3. 后缀为0时，只能与前一个字符拼接。如果str[0...i-2]都不存在分解方案，那i和i-1拼成了也不行。
4. 后缀不为0，转换有两种方式。 依赖dp[i-1]和dp\[i-2]。与前一个字符拼接时，前一个字符不能为0。

### 贴纸拼词|多少张贴纸可以贴出给定字符串

给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文

arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来

返回需要至少多少张贴纸可以完成这个任务。

例子：str= "babac"，arr = {"ba","c","abcd"}，

两种方式：ba + ba + c 3    abcd + abcd 2    abcd + ba 2，所以返回最少2张。

**分析**

暴力尝试：

1. 字符串排序（提高命中率），肯定有某一张贴纸做为第一张，所以尝试所有的贴纸。
2. 第一张贴纸选ba，看之后总共需要几张贴纸。
3. 第二张贴纸选c，看之后总共需要几张贴纸。
4. 第三张贴纸选abcd，看之后总共需要几张贴纸。
5. 取最小的张数+1就是结果。也可能没有有效结果。

优化1：

1. 因为出现的字符都是小写英文，所以char[26]可以表示一个字符串中每个字符出现的次数。
2. 使用**词频统计表**（二维数组），代替贴纸数组，速度快。
3. 贪心策略：因为要完成任务，肯定有贴纸能消掉目标字符串的第一个字符，所以让只含有第一个字符的贴纸先试，不影响结果。不用每个贴纸都试。
4. 只有包含目标字符串的指定字符，才进行递归查找。**实现剪枝**。

优化2：**记忆化搜索优化**，没有必要改为严格表结构的动态规划

1. 因为可变参数是字符串，无法确定变化范围，临界值很多。
2. 不同于整型，整型的下标可以确定范围。
3. 所以只需要记忆化搜索。不用严格表结构的动态规划。

**结论**

这个题在所有的尝试中，地位很高。

**尽量做到使用严格位置依赖，像这个题只能用傻缓存**。因为很多进阶技巧来自整理好依赖后的进一步优化。

### 两个字符串的最长公共子序列

**子序列：可以不连续，且顺序不变的一串字符。**

**子串：必须连续，且顺序不变的一串字符。**

给定两个字符串str1和str2，返回这两个字符串的最长公共子序列长度

例子：str1 = “a12b3c456d”,str2 = “1ef23ghi4j56k”，最长公共子序列是“123456”，所以返回长度6。

**分析**

是**样本对应的尝试模型**，它的经验是**往往讨论当前样本范围的结尾该如何组织可能性**。

Str1[0.....i]，Str2[0....j] 两个字符串的公共子序列，i!=0&&j!=0时的可能性如下：(**也就是缩减样本的方法**)

1. 公共子序列不考虑i位置的字符，即不以 i 结尾，但有可能考虑j位置

2. 公共子序列不考虑j位置的字符，即不以 j 结尾，但有可能考虑i位置

3. 公共子序列以i和j结尾，str1[i]==str2[j].

4. 两种可能性有重叠，即不考虑i位置，也不考虑j位置，因为是求最大，所以不影响。

   例如：i位置的字符== j位置的字符，公共子序列的结尾是i位置的字符。

可能性也可以是：

1. 公共子序列不考虑i位置的字符，也不考虑j位置的字符。
2. 公共子序列不考虑i位置的字符，但一定是以j结尾。
3. 和上一种方式相比，一定是以j结尾，可能性讨论变的麻烦，因为需要验证Str1中有没有j位置的字符。

动态规划：

1. 两个可变参数i和j，所以使用一个二维表能存储每个位置的结果。
2. 从递归尝试中分析依赖，一个位置的结果需要三个已算好的位置（**左，左上，上**）
3. 先计算第一行和第一列的值，则之后的结果从上到下，每行的值都可以计算。 
4. **起始值为第一行和第一列** ，str1="a1bc" str2="ef1b"  1b.

| Str1[i]/Str2[j] | 0    | 1    | 2    | 3    |
| :-------------: | ---- | ---- | ---- | ---- |
|      **0**      | 0    | 0    | 0    | 0    |
|      **1**      | 0    | 0    | 1    | 1    |
|      **2**      | 0    | 0    | 1    | 2    |
|      **3**      | 0    | 0    | 1    | 2    |

**结论**

是**样本对应的尝试模型**，它的经验是**往往讨论两个样本范围的结尾该如何组织可能性**。

### 最长回文子序列

给定一个字符串str，返回这个字符串的最长回文子序列长度

比如 ： str = “a12b3c43def2ghi1kpm”

最长回文子序列是“1234321”或者“123c321”，返回长度7

**分析**

是**范围上的尝试模型**，时间复杂度O(N^2)

常常讨论范围的开头B和结尾E，对于两个可变参数结合的可能性，组成的结果可能是：(**也就是缩减范围的方法**)

1. 最长回文子序列的第一个字符不是B，有可能是E。（下）
2. 最长回文子序列的第一个字符不是E，有可能是B。（左）
3. 最长回文子序列的第一个字符不是B，也不是E。（左下）
4. 最长回文子序列的第一个字符是B，也是E。 B和E必须相同。（左下加2）

动态规划： 使用严格表结构

1. 两个可变参数B和E，取值范围为N-1，组成一个的二维数组存储每一个范围内的结果。

2. 从递归中分析依赖，一个位置的结果需要三个已算好的位置（左，左下，下）

3. 因为范围的开始位置不能小于结束位置，所以左下区域无效。

4. 先计算第一条对角线和第二天对角线，则之后的结果从下到上，每行的值都可以计算。 

5. **起始值为两条对角线** ，str1=“2bc2e”， 

   | **B\|E** | **0** | **1** | **2** | **3** | **4** |
   | -------- | ----- | ----- | ----- | ----- | ----- |
   | **0**    | 1     | 1     | 1     | 3     | 3     |
   | **1**    |       | 1     | 1     | 1     | 1     |
   | **2**    |       |       | 1     | 1     | 1     |
   | **3**    |       |       |       | 1     | 1     |
   | **4**    |       |       |       |       | 1     |

优化：剪枝

4中可能性中，结果是【左下+2，左，左下，下】的最大值。所以对于下一个位置的来说，它的左位置一定大于左下位置，所以可以减少一种可能性。不用和左下位置进行比较。

**发散思维**

给定String1，将其倒序生成String2，则String1和String2的最长公共子序列，就是String1的最长回文子序列。

因为回文的倒序和正序相同，所以可以**将范围上的尝试模型，改为了样本对应的尝试模型。**

**结论**

一个问题会有多种尝试搞出答案, 一定要会写尝试

### 象棋问题-马只走K步跳到指定位置的方法数

请同学们自行搜索或者想象一个象棋的棋盘，

然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置

那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域

给你三个 参数 x，y，k （**马走日**）

返回“马”从(0,0)位置出发，必须走完k步，最后落在(x,y)上的方法数有多少种? 

**分析**

如果位置依赖特别复杂, 就不改严格动态规划, 用傻缓存就行了

暴力尝试：

1. base case 当k=0, x=a,y=b时，返回1，否则返回0，表示之前尝试的步骤是无效的，此方法错误，不计入结果。
2. 马走日，所以每一步都有8个可以移动的位置。但注意棋盘的边界。
3. 取所有方法的和为结果。

动态规划：三维数组（行列层），每一步一层，同一层的位置没有相互依赖，都只依赖下一层。如第一步k依赖第二步k=k-1。

### 所有咖啡杯变干净的最早时间

数组arr代表每一个咖啡机冲一杯咖啡的时间，每个咖啡机只能串行的制造咖啡。

现在有n个人需要喝咖啡，只能用咖啡机来制造咖啡。

认为每个人喝咖啡的时间非常短，冲好的时间即是喝完的时间。

每个人喝完之后咖啡杯可以选择洗或者自然挥发干净，只有一台洗咖啡杯的机器，只能串行的洗咖啡杯。

洗杯子的机器洗完一个杯子时间为a，任何一个杯子自然挥发干净的时间为b。

假设时间点从0开始，返回所有人喝完咖啡并洗完咖啡杯的全部过程结束后，至少来到什么时间点。【返回从开始等到所有咖啡杯变干净的最短时间（京东面试题）】

**分析**

**寻找业务限制的尝试模型**，范围上尝试的模型：四个参数：int[] arr、int N，int a、int b

分解题意，有两个过程：

1. 所有人先在咖啡机前排队，获得**所有人的咖啡都做好的最短时间**。
2. 洗杯子或自然挥发，让所有**咖啡杯变干净的最短时间**

递归尝试：

1. 做咖啡的递归

   1. 参数：int[] arr、int N，int a、int b，**int[] time(每台咖啡机空闲的时刻)，int[] drink(每个人喝完咖啡的时刻)，index(第几个人)**

   2. base case : 当index==N时，所有人都喝完咖啡，对drink排序，并获取洗干净所有杯子的最短的时间。

   3. 每个人都尝试在每一台咖啡机前排队，取第index个人在每台咖啡机前排队花费的最少时间。

      需要设置time和drink的值，比较完结果后，要恢复现场数据，进行下一次的选择。

2. 洗杯子的递归：

   1. 参数：int[] drink，int a、int b，**int washline(洗杯机空闲时间)，int time(累计消耗的时间)，int index(第几个杯子)**

   2. base case: 当index=drink.lenth时，所有杯子都洗完，返回累计消耗的时间time。

   3. 每个杯子有两种方式，在洗杯机前排队，或自然挥发。

      每种方式花费的时间需要和上一次的累计时间time进行比较，最大值就是每种方式的累计消耗时间。

      washline是 喝完咖啡的时间和洗杯机空闲时间的最大值，再加上洗一次的时间。

   4. 返回两种方式下，杯子全部洗完的最小时间。

递归优化：

1. 做咖啡的递归：使用贪心策略，每个人在做完咖啡的时间最短的咖啡机前排队。

   使用小根堆，用泡咖啡花费的时间和咖啡机空闲的时刻组合排序，每个人获取最小值，并更新咖啡机的空闲时刻，排队完成，得到每个人泡完咖啡的时刻。（时刻就是从当前开始算，过多少小时才能完成任务）。

2. 洗杯子的递归，减少可变参数，去掉time(累计消耗的时间)，当前杯子洗完的时间和下一次杯子洗完的时间，取最大值，就是每种方式的累计消耗时间。

动态规划：

1. 分析可变参数，确定严格位置依赖的表范围。

2. 按可变参数的最大程度来统计，free（洗杯子机可以使用的时间）的无法明确范围大小，需要先根据业务逻辑计算free的最大值。

   **限制不够，业务来凑。**假设都用洗杯机洗，遍历drinks，maxFree = Math.max(drink[i]，maxFree) + wash.

3. 因为base case的条件包含N，maxFree的值也包含，dp=new int [n+1]\[maxFree+1]

4. 填表时，确认哪些位置不需要填，如越界问题：因为free<=maxFree, 所以dp\[index+1]\[free+wash\] 就会越界。

   因为maxFree是所有杯子用机器洗的最大总时间，没必要讨论N之前的洗杯子机的空闲时间会大于maxFree的情况，所以在N之前的真实的递归中不会调用到这个状态。表中不填数据。

   当0 - n-1都使用洗杯机，则free=maxFree，clean1=maxFree+wash>maxFree

5. 按递归逻辑分析依赖关系，是每一行都依赖下一行的数据。所以从下往上填数据。

6. **起始值为最后一行，都为0**， arr={7，3，7，9}  n=5，a=5，b=10   drink={3,6,7,7,9}

   | index\|freetime | 0    | 8    | 12   | 13   | 17   | 18   | 23   | 28   |
   | --------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | 0               | 17   | 17   | 17   | 19   | 19   | 19   | 19   | *    |
   | 1               | 17   | 17   | 17   | 18   | 19   | 19   | 19   | *    |
   | 2               | 17   | 17   | 17   | 18   | 19   | 19   | 19   | *    |
   | 3               | 17   | 17   | 17   | 18   | 19   | 19   | 19   | *    |
   | 4               | 14   | 14   | 17   | 18   | 19   | 19   | 19   | *    |
   | 5               | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

### 矩阵中的最小路径和

给定一个二维数组matrix，一个人必须从左上角出发，最后到达右下角

沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和

返回最小距离累加和

**分析**

动态规划：

1. dp\[i]\[j]表示(0,0)到(i,j)位置的最小距离累加和，或是(i,j)到右下角(row,col)位置的最小距离累加和
2. 每个位置的依赖关系是，当前值是其左和上的最小值，再加上二维数组matrix中该位置的值。

**优化：动态规划表的空间压缩**

1. 对于当前值依赖其**左和上**的值，可以使用一维数组，从左往右填入值。
2. 对于当前值依赖其**左上和上**的值，可以使用一维数组，从右往左填入值。
3. 对于当前值依赖其**左，左上和上**的值，可以使用一维数组和一个临时变量，从左往右填入值。
4. 行与列，如果行数4小于列数100，一维数组长度为行数，则从往右，一列一列的填入值。

### 货币面值系列

#### 货币数组组成面值的方法数-同值认为不同 

arr是货币数组，其中的值都是正数。再给定一个正数aim。

每个值都认为是一张货币，即便是值相同的货币也认为每一张都是不同的，

从arr index出发及其后面所有货币自由选择, 组成正好aim这么多的钱有几种方法.

例如：arr = {1,1,1}，aim = 2

第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2，一共就3种方法，所以返回3。

**分析**

使用**从左往右的尝试模型**，因为aim有明确的变化范围，从0-aim。

递归尝试：

1. 尝试arr[index.....]组成rest这么多钱的所有办法。
1. 参数：货币索引index，还要选多少钱rest。
2. base case：rest<0 选择无效，index==arr.length && rest\==0, 返回1，找到一种方法。
3. 每次尝试都有两种方式，包含当前货币，或者不包含当前货币。

动态规划：

1. index范围：[0，arr.length]， rest范围：[0，aim]    dp[N+1][aim+1\]
2. 规划表中，每一个位置的值都依赖于下一行的某一个值。
3. 起始位置：**最后一行，只有rest为0时，证明有一种方法，dp[N]\[0]=1，其余都为0;**

#### 面值数组组成面值的方法数-张数不限

arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。

每个值都认为是一种面值，且认为张数是无限的。

从arr index出发及其后面所有的面值, 每一个面值都可以自由选择, 组成正好aim这么多的钱, 方法数是多少?

例如：arr = {1,2}，aim = 4

方法如下：1+1+1+1、1+1+2、2+2，一共就3种方法，所以返回3

**分析**

使用**从左往右的尝试模型**。

有大量重复解：动态规划有利可图。

1. {5，2，10.....}  aim是100。 
2. 4张5，0张2，0张10，下标来到3，结果为f(3,80)
3. 0张5，10张2，0张10，下标来到3，结果为f(3,80)

递归尝试：

1. arr[index.....]所有的面值，**每一个面值都可以任意选择张数**，组成正好rest这么多钱，方法数多少
1. 参数：面值的索引位置Index，剩余钱数Rest
2. base case: index==arr.length 没钱了， 若rest\==0, 返回1，找到一种方法。
2. 每次尝试当前index位置都有枚举行为（**当前面值选择多少张**），枚举范围是剩余钱数[0....Rest]，循环执行。

动态规划：

1. 可变参数范围：index范围：[0，arr.length]， rest范围：[0，aim]    dp[N+1][aim+1\]
2. 规划表中，每一个位置的值都依赖于下一行的多个（从0 ~ 当前位置的左下个）值的和。
3. 起始位置：**最后一行，只有rest为0时，证明有一种方法，dp[N]\[0]=1，其余都为0;**

在严格表结构上的优化：

1. 通过严格表结构，建立空间感，找出优化机会。
2. 可以观察出当前位置的左值，是下一行中，除了当前位置的下，其它枚举值的和。
3. 当前位置的枚举行为可以被临近位置的值替代。
4. **动态转移方程变得简单，由循环改为常数的决策方式**。

#### 货币数组组成面值的方法数-同值无差别(张数限定)  

arr是货币数组，其中的值都是正数。再给定一个正数aim。

每个值都认为是一张货币，认为**值相同的货币没有任何不同**，

从arr index出发及其往后所有的面值在张数规定好的情况下组成aim的方法数。

例如：arr = {1,2,1,1,2,1,2}，aim = 4

方法：1+1+1+1、1+1+2、2+2，一共就3种方法，所以返回3

**分析**

**值相同的货币没有任何不同**，所以可以对货币数组进行去重，记录每个面值的张数，转为**面值数组和张数数组**。

题意和上一题相似，还是**从左往右的尝试模型**，只是张数有限制。需要在递归和动态规划中修改动态转移方程。

动态规划的斜率优化：

1. 每一个位置的值都依赖于下一行的固定个值的和。
2. 所以当前位置的值等于：**0张的情况，大于0张的情况，和多出的情况**
   dp[index+1]\[rest\] + dp[index\][rest-arr[index]] -  dp[index+1]\[rest - (count+1) * arr[index]]
3. 特殊情况：当张数足够大，rest小，则永远用不完。直接加左值，没有重复情况，因为张数面值大于**左值的rest**

### Bob生还的概率

给定5个参数，N，M，row，col，k

表示在N*M的区域上，醉汉Bob初始在(row,col)位置

Bob一共要迈出k步，且每步都会等概率向上下左右四个方向走一个单位

任何时候Bob只要离开N*M的区域，就直接死亡

返回k步之后，Bob还在N*M的区域的概率

**分析**

每一步是等概率的4种情况，所以总的情况数是4^K（满多叉树的最后一层的个数）。

三维的动态规划（行列层，步骤数），先算0层，再算1层.....n层，象棋跳马问题。

是**从左到右的尝试模型**，而不是正态分布。

### 英雄砍死怪兽的概率

给定3个参数，HP，M，K

怪兽有HP滴血，等着英雄来砍自己

英雄每一次打击，都会让怪兽流失[0~M]的血量

到底流失多少？每一次在[0~M]上等概率的获得一个值

求K次打击之后，英雄把怪兽砍死的概率。（**也可以是1-活着的概率**）

**分析**

每一次都是有m+1次的展开，总的情况数是(m+1)^K.

**每次尝试中，HP有负的情况。**

递归尝试：

1. 从**样本对应的尝试模型**。（HP和K，从两个样本的结尾变化）
2. 可变参数：怪兽血条HP和K次打击
3. 每次打击，等概率有M+1种可能。

动态规划：

1. 表范围：**dp\[K+1][HP+1]，不去计算HP为负的情况**，因为那样会增加复杂度，浪费空间，
2. 每次打击HP-M，所以怪兽HP可能为负，使用数组需要注意越界问题。
3. 减枝优化：如果还有3刀的时候，怪兽HP<=0，则砍死怪兽的次数是（M+1)^3
4. 包含枚举行为：M+1种可能.

**总结**：

1. 推表的过程中，发现使用原始的递归过程做出等量的表不好推，想要把表压缩一下，
2. 进而总结出减枝的策略，把它补进递归里。
3. 逻辑概念上，是有小于0的情况，但实际物理结构只从0开始，左边为0的区域用公式计算。

斜率优化：

1. 每一个位置，依赖上一行中，每次打击，损失（M+1种）血后的HP的值，它们的和。

2. 如：M=7为{0,1,...,7} , dp[5]\[10] = dp[4]\[10....3] 的和。 dp[5]\[11] = dp[4]\[11.....4]. 

   所以：dp[5]\[11] = dp[5]\[10] + dp[4]\[11] - dp[4]\[3]

3. 得到公式：dp[K]\[HP] = dp[K-1]\[HP] + dp[K]\[HP-1]  -  dp[K-1]\[HP-1-M]
4. 若HP-1-M<0, 则：HP为负数的情况，使用减枝优化的公式：（M+1)^(K-1)
5. 使用简单的例子，建立空间感，推出优化策略。

### 面值数组组成面值的最少货币数

arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。

每个值都认为是一种面值，且认为张数是无限的。

返回组成aim的最少货币数

**分析**

递归尝试：

1. **从左到右的尝试模型**。

2. 两个可变参数可变范围：[0....aim] , [0.....arr.length]

3. base case: index==arr.length 时，如果aim\==0，则返回0(选择0张货币)， 否则返回Integer.Max_Value(这次尝试无效)

   返回-1和Integer.Max_Value的区别：因为是算每次枚举行为的最小值，-1会影响结果，需要增加判断，但Integer.Max_Value与其它结果对比取最小，不会影响结果。

4. **在递归方法里，注意每个可变参数的范围**。

5. arr[index.....N]的面值，组成rest剩余货币的最少张数。

动态规划：

1. 有枚举行为，进行斜率优化：枚举行为可用左侧位置代替

2. 示例：rest=14, arr[0] = 3 当前 dp[0]\[14]  就是 Math.min ( dp[1]\[14] + 0  , dp[1]\[11] + 1 , dp[1]\[8] + 2.... )

   意思就是：若用了1张，则剩下11元用了dp[1]\[11]张，则总共用的时dp[1]\[11] + 1张，

   dp\[0][14] = Math.min(dp\[0][11]+1，dp\[1][14])

3. 若dp[0]\[11]是Integer.Max_Value，则可知对于dp[0]\[14]来说，dp[1]\[11]，dp[1]\[8]，dp[1]\[5]都是无效值。

### 给定一个正整数n, 求裂开的方法数

给定一个正数n，求n的裂开方法数，

规定：后面的数不能比前面的数小

比如4的裂开方法有：1+1+1+1、1+1+2、1+3、2+2、4    总共5种，所以返回5

**分析**

递归尝试：

1. 示例：拆分6， 若第一次用1拆，计算剩下5的拆解次数。（补一个前置条件）
2. 因为后面的数不能比前面的数小，所以第一次要拆的数从1开始。
3. base case:  pre > rest 返回0，rest==0时，返回1.
4. 返回当拆解的值为pre, 剩余rest数需要拆解的方法数。

动态规划：

1. 表范围：dp=int [n+1]\[n+1]   (pre,rest)

2. base case得到**起始位置：第一列为1，对角线为1.**  pre>rest为0， rest=0为1， rest=pre为1， 

3. 依赖关系：当前位置依赖 左位置[pre,rest-pre]开始的左下斜线上的数值的累积。按从下而上，从左往右填充值。

   (3,4) => (3,1) + (4,0)；(2,4)=>（2,2) + (3,1) + (4,0) ; (2,3)=> (2,1)+(3,0)

   | pre\|rest | 0    | 1    | 2    | 3    | 4    |
   | --------- | ---- | ---- | ---- | ---- | ---- |
   | 0         | X    | X    | X    | X    | X    |
   | 1         | 1    | 1    | 2    | 3    | 5    |
   | 2         | 1    | 0    | 1    | 1    | 2    |
   | 3         | 1    | 0    | 0    | 1    | 1    |
   | 4         | 1    | 0    | 0    | 0    | 1    |

优化状态依赖的技巧：斜率优化

1. 观察的出：当前位置的下方位置的斜线，包含在当前位置的斜线中。
2. 当前位置的上下左右8个位置的值观察一遍，尝试依赖关系。
3. 所以：dp[pre]\[rest] = dp[pre+1]\[rest]  +  dp[pre]\[rest-pre]

### 正数数组分割为累加和接近的两个集合

给定一个正数数组arr，

请把arr中所有的数分成两个集合，尽量让两个集合的累加和接近

返回：最接近的情况下，较小集合的累加和

示例：[100，3，4，5]  拆成两个集合[3，4，5] sum=12，[100] sum=100.  这是两个集合的累加和最接近的情况，返回12.

**分析**

尽量让两个集合的累加和接近，其**含义就是较小集合的累加和尽量接近数组总和的一半**。

递归尝试：

1. 数组从0出发，自由选择，返回累加和最接近总和的一半，但不能超过的情况，最接近的较小累加和。
2. **从左到右的尝试模型**，当前位置要或者不要。
3. base case : index== arr.Length 时，没有数值，所以在(arr.length，rest)上的最小累加和为0.
4. 每次尝试有两种选择：选择arr[i] （**当前位置的累加和是：下个位置的累计和加上当前值**）和 不选择arr[i]的情况，取最大，就是接近中间值的累加和。（**绘制二叉树，树上返回时需要加上当前节点的值**）

在某些情况下有重复值：如[5，2，3.......]   <=中间值20， [oxx] 和 [xoo]  都是(5，15)的情况。则动态规划有利可图。

动态规划：

1. 可变参数范围：dp = new int[n+1]\[midsum+1]， 最终返回的位置[0，midsum]
2. 根据base case 初始化表， **起始位置：最后一行为0**   index==arr.length  返回0.
3. 分析普遍位置的依赖：每个位置都依赖下一行的值。从底往上推。

**结论**

题目中，数组中数值范围未规定，如果数值范围大，根据累计和做出的表就很大，再用动态规划就不合适了。

之后会有其它根据具体数据状况去优化的方案。

### 正数数组分割为个数跟累加和接近的两个集合

给定一个正数数组arr，请把arr中所有的数分成两个集合

如果arr长度为偶数，两个集合包含数的个数要一样多

如果arr长度为奇数，两个集合包含数的个数必须只差一个

请尽量让两个集合的累加和接近

返回：最接近的情况下，较小集合的累加和

**分析**

题意解析：

1. arr长度为奇数，两个集合包含数的个数必须只差一个，结果不一定是包含数最少的集合。
2. 如：[100，1，1，1，1]    拿够3个数的集合是[1，1，1]，拿够4个数的集合是[1，1，1，1]
3. 需要返回两种方式的累加和的最大值。

递归尝试：

1. 是**从左到右的尝试模型**，当前位置要或者不要。
2. 可变参数，arr的索引位置Index，rest目标值(总数的一半)，**集合的限制个数picks**
3. base case:  到终止位置arr.Length，picks不为0，则说明之前的选择无效，凑不齐指定了个数的集合，返回-1。**picks一定小于arr.Length**
4. 每次尝试有两种方式：选择当前位置：rest-arr[i], picks-1；不选择当前位置，picks，rest。

动态规划：

1. 奇数除以2向上取整公式：(N+1)/2
2. 可变参数有三个，使用三维数组，rest和picks组成一个平面，N为第三轴。返回第0层的值。
3. 根据base case初始化**起始值，最后一层dp[N]\[0]\[0.....rest] = 0， 其他值为无效值-1.**
4. 分析普遍位置的依赖，N-1依赖N层。

### N皇后问题

在N*N的棋盘上要摆N个皇后，

要求任何两个皇后不同行、不同列， 也不在同一条斜线上 给定一个整数n，返回n皇后的摆法有多少种。

例如：n=1，只有一个格子摆一个皇后，返回1，n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0，n=4时，返回2，表格中展示一种状态。

|      | *    | ✦    |      |
| ---- | ---- | ---- | ---- |
| ✦    |      |      | *    |
| *    |      |      | ✦    |
|      | ✦    | *    |      |

**分析**

**不能改动态规划, 得到绝对的方法数，只能用暴力**，常用于测试超级计算机的性能。想得到N很大时候的最优解，只能用暴力。

递归：

1. 流程严格限制一行一行的填皇后，每一行只填一个皇后，所以皇后不用检查共行的问题。
2. 使用一维轨迹数组record，记录每个皇后填的位置，第二个皇后与之前的每个皇后位置，进行判断，是否符合要求。
3. 抽象化，位置（x,y)，共列：y1\==y2，共斜线：|y1-y2|==|x1-x2|

时间复杂度：O(N^N)，经典的暴力问题。

优化：时间复杂度相同，只优化常数时间：

1. 使用位运算，使用整数值的状态来代替record数组，因为数组寻址会比位运算慢。
2. 每一次摆完皇后，更新下一个皇后可摆的位置，
3. 32以上的皇后问题，会超过整数的表达范围。
4. base case: limit==post  只拦截有效值，无效的跳过while返回0.

示例4皇后中，第一行1位置摆放皇后，oxoo

1. 列限制：    oxoo
2. 左下限制：xooo
3. 右下限制：ooxo

第二行可摆放的位置在 3个限制位置**位运算：或**后不为x的位置 xxxo，在3位置摆放皇后，ooox

1. 列限制：    oxox
2. 左下限制：ooxo（上一次左下限制**或**当前位置，需要左移一位）
3. 右下限制：ooox（上一次右下限制**或**当前位置，需要右移一位）

第三行可摆放的位置在 3个限制位置**位运算：或**后不为x的位置 oxxx，在0位置摆放皇后，xooo

1. 列限制：    xxox
2. 左下限制：oxoo（上一次左下限制**或**当前位置，再需要左移一位）
3. 右下限制：oxoo（上一次右下限制**或**当前位置，再右移一位）

第四行可摆放的位置在 3个限制位置**位运算：或**后不为x的位置 xxox，在2位置摆放皇后，ooxo