# 贪心算法

## 定义

在对问题的求解时，总是做出在当前看来是最好的选择。不从整体最优上考虑，得到的是局部最优解。

贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。

1）是最自然智慧的算法

2）用一种局部最功利的标准，总是做出在当前看来是最好的选择(绝对标准下的解)

3）难点在于证明局部最功利的标准可以得到全局最优解,  

4）对于[[贪心算法]]的学习主要以增加阅历和经验为主

## 求解过程

1，分析业务

2，根据业务逻辑找到不同的贪心策略, (**不能得到全局最优解,则证明贪心策略无效**).

3，对于能举出反例的策略直接跳过，不能举出反例的策略要证明有效性

**这往往是特别困难的，要求数学能力很高且不具有统一的技巧性**

## 解题套路

1，实现一个不依靠贪心策略的解法X，可以用最暴力的尝试

2，脑补出贪心策略A、贪心策略B、贪心策略C...， 用**排序，或小根堆, 大根堆**，或其它结构实现。

3，用解法X和对数器，用实验的方式得知哪个贪心策略正确 

4，不要去纠结贪心策略的证明 

## 题目

1. 矩阵往返一次的最大路径和.   (矩阵两侧各有一个1, 不在同一行, 左上角到右下角是“之”字的1)

   从左上角到右下角过程中,只能向下和向右,  

   从右上角到左下角过程中,只能向上和向左,  

   沿途有0和1, 往返经过相同的1,只能算1个. 求往返得1最多.

   分析: 贪心策略, 去的时候经过1最多, 回来的时候经过1也最多.

   反例: 两侧的1, 只能有一个1能取到.  无法经过所有1.

   最优解:  去时 左上角到左1, 再到右下角,  回时右下角到右1, 再到左上角

   是一道**使用贪心算法无法得到最优解**的例子。

2. 字符串组成的数组拼接后字典序最小的结果

   给定一个由字符串组成的数组strs，

   必须把所有的字符串拼接起来，

   返回所有可能的拼接结果中，字典序最小的结果

   1. 分析: [“b", "ba"], 

      失败的贪心策略, 数组中字符串排序后, 再拼接. (反例:  bba > bab ).

      成功的贪心策略, 使用比较器,  按不同顺序拼接后得a和b if (a < b) a在前 else b在前

   2. 证明排序策略是有传递性的.  a<b ,b<c 得到a<c.   在这样的排序策略下得到的结果是唯一的.  数字,字符串天生具有传递性, 但像石头,剪刀,布组成数组, 其无传递性, 是无效的比效策略. 

      如何证明: (.)表示拼接,  如果a.b <= b.a  b.c <= c.b  则 a.c <= c.a

      假如字符串的进制是K, 都是非负的整数, 其用数学代替 : “123”.“456” = “123”*k^3+"456" ("123"左移3位, 占高位, 再把“456”填充到低位)

      K^x长度 = M(x) 用一个函数表示. 因为字符串代表数字(ASSIC码), a, b, c都是正整数, 所以同时乘以c正负不变

      a.b <= b.a；a\*M(b) + b <= b\*M(a) + a； a\*M(b)  <= b\*M(a) + a \- b；  a\*M(b) \* c <= b\*M(a)\*c + a\*c \- b*c；

      b.c <= c.b；b\*M(c) + c <= c\*M(b) + b； b\*M(c) + c - b <= c\*M(b)；    a\*b\*M(c) + c\*a - b\*a <= a\*M(b) \*c；

      因为字符串是非负的整数, 满足乘法的交换律和结合律, a\*b\*M(c) + c\*a - b\*a <= b\*M(a)\*c + a\*c \- b*c

      最终得: a\*M(c) + c <= c\*M(a) + a.  则 a.c <= c.a

      结论: 使用排序策略得到有序的数组中  [前, 后], 一定有: 前.后 <= 后.前 因为传递性.

   3. 排序后的数组中, 证明只要交换前后任意两个字符串, 字曲序只增不减.

      [...a,m1,m2,b.....] 因为排序策略 所以a<=m1 , a.m1 <= m1.a <= [...b,m1,m2,a....]. 

   4. 实际中, 一般不证明, 使用对数器进行实验.

3. 会议室能容纳的宣讲场次

   一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。

   给你每一个项目开始的时间和结束的时间，你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。

   返回最多的宣讲场次。 

   1. 分析: 一组项目 [1,3], [1,5], [2,4], [3,6]。 选择 [1,3],  [3,6]时, 项目的宣讲场次最多.

   2. 贪心策略1:每一次先选开始时间小的项目, 再从剩下的项目中选开始时间小的项目, 符合就增加, 不然就删除, 再从剩下的项目中选开始时间小的项目, 直到项目为空.

      反例: 第一个开始时间小的项目,结束时间很大, 则此策略下宣讲场次是一次.

   3. 贪心策略2: 选持续时间短的.

      反例:  [1,27], [26,31], [29,300], 此策略下宣讲场次是一次, 但最优是2次。

   4. 贪心策略3: 按结束时间排序， 先选结束时间小的项目

      可得最优解。用暴力后序递归证。

4. [[金条分割的最小代价]]  

   一块金条切成两半，是需要花费和长度数值一样的铜板的。

   比如长度为20的金条，不管怎么切，都要花费20个铜板。 一群人想整分整块金条，怎么分最省铜板?

   例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为60，金条要分成10，20，30三个部分。

   如果先把长度60的金条分成10和50，花费60; 再把长度50的金条分成20和30，花费50;一共花费110铜板。

   但如果先把长度60的金条分成30和30，花费60;再把长度30金条分成10和20， 花费30;一共花费90铜板。

    输入一个数组，返回分割的最小代价。 

   1. 分析： [10,20,30]  无序分割的最小代价。 如[10,50] [20,30] 花费共110

   2. 贪心策略1: 先选最大的.  [30,30] [20,10]  花费共90

      反例:[97,98,99,100]   策略下花费394 + 294 + 195  最优[97,98] [99,100]  花费394  + 195 + 199

   3. 贪心策略2: 小根堆， 每次前两个数弹出，相加后入堆，直到堆的大小为1， 所有相加得的数， 反过来看，就是每次分割的花费。

      **逆向思考： 整体->部分 分割的最小代价， 等同于部分->整体 组合的最小代价。**
      
      可得最优解。用暴力后序递归证。

5. [[点亮str中所有需要点亮的位置至少需要几盏灯]]  -**精典题**

   给定一个字符串str，只由‘X’和‘.’两种字符构成。

   ‘X’ 表示墙，不能放灯，也不需要点亮； ‘.’ 表示居民点，可以放灯，需要点亮。

   如果灯放在i位置，可以让i-1，i和i+1三个位置被点亮

   返回如果点亮str中所有需要点亮的位置，至少需要几盏灯

   1. 贪心策略1: 若三个位置都是".", 则灯放中间。

6. [[做项目获得的最大钱数]]  

   输入: 正数数组costs、正数数组profits、正数K、正数M

   costs[i]表示i号项目的花费

   profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润)

   K表示你只能串行的最多做k个项目

   M表示你初始的资金

   说明: 每做完一个项目，马上获得的收益，可以支持你去做下一个项目。不能并行的做项目。

   输出：你最后获得的最大钱数。 
   
   1. 分析： 项目数组为[cost=5,profits=1], [1,3], [2,5], [6,4]   初始资金M是1， K最多做3个， 最大钱数的完成项目是[1,3], [2,5], [6,4]  最大钱数是4+5+4=13.
   
   2. 贪心策略1: 所有项目按花费组成小根堆，  按利润组成大根堆， O(N*logN)
   
      通过M   筛选项目  从小根堆  放入  大根堆
   
      做大根堆的顶部项目， M增加。 
   
      直到K凑满 ，或大根堆为空。

## 字典序

 两个字符串, 放到字典中, 谁先放在前面, 谁的字典序就最小

>严格定义:  认为字符串就是K进制的正数, 分两种情况:
>当两个字符串长度一样, 直接认为是K进制的正数进行比较 (**转为ASSIC码,比较数值**)
>当两个字符串长度不一样的时候, 短的用最低的ASSIC码补齐, 通过补0完成(认为0的ASCII比a还小)