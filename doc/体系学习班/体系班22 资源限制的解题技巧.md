# 资源限制技巧汇总

1. 布隆过滤器用于集合的建立与查询，并可以节省大量空间  

2. 一致性哈希解决数据服务器的负载管理问题  

3. 利用并查集结构做岛问题的并行计算    

4. 哈希函数可以把数据按照种类均匀分流  

5. 位图解决某一范围上数字的出现情况，并可以节省大量空间  

6. 利用分段统计思想、并进一步节省大量空间  

7. 利用**堆、外排序（遍历）**来做多个处理单元的结果合并  

面试时，需要和面试官问清楚限制条件。

# 题目

## 哈希分流

32位无符号整数的范围是0~4,294,967,295，

现在有一个正好包含40亿个无符号整数的文件，

可以使用最多1GB的内存，怎么找到出现次数最多的数？

**一般做法：**

无符号整数是4字节，40亿需要占用160亿字节，大约是16GB。因为内存资源限制，所以不能声明40亿长度的int数组，直接进行排序统计。

**有限资源的做法：**

统计出现次数，可以使用**HashMap，key存储值，value存储出现次数**。数据范围是0~42亿，是$0\dots 2^{32}-1$.

所以哈希表的大小是和**数据种类**有关。

1. 若文件是40亿个1，则HashMap只有一条记录，占用8个字节。
2. 若文件是40亿个不同的数，则HashMap有40亿条记录，占用320亿个字节，32GB。
3. 更不满足资源限制条件。

先从资源限制的条件分析：

1. 1GB内存，哈希表最多可以存储1GB/8条记录，大约是1亿条。再减去哈希表内部实现所占用的空间，为了内存不溢出，直接除以10，得到**最多存储1千万条记录**。
2. 40亿个无符号整数，**最多有40亿种不同的数**。
3. 40亿除以1千万=400，则可知每次最多处理1千万条记录，**只需400次就可处理完**40亿个整数。

通过上面的结果可以使用哈希分流：

1. 40亿个数，都计算HashCode，再%400，就可以几乎均匀放在400个不同的文件中。

   大文件是一个个读取到内存中，计算完，再写入到400个不同的文件中，**不占内存**。

2. 先处理完1号文件中出现次数最多的数，释放掉空间，再处理2号文件.....直到400号文件，就得到400个出现次数最多的数，再取最大。

3. 抓取最大值：使用两个变量存储值和最大出现次数，再遍历每个块中的数据。

总结：

1. 如果有一个大文件，且内存资源有限，统计大文件的一些信息，当使用内存做哈希表或其它数据结构，内存会爆掉，常见的作法就是将大文件的所有数据，计算hashcode，再模一个数N，把数据分成N份。
2. N值可以很大，也可以把分完的每一块，再用第二个哈希函数计算hashcode，模一个数M，再往下分。
3. 最后进行结果整合。
4. **N个数计算Hash Code，再%M，则N个数在（0，M-1）上均匀分配。**

哈希碰撞不影响，因为我们就是要将不同种类的数放在同一个块里处理。

## 使用位图

32位无符号整数的范围是0~4,294,967,295，

现在有一个正好包含40亿个无符号整数的文件，

所以在整个范围中必然存在没出现过的数。

可以使用最多1GB的内存，怎么找到所有未出现过的数？

**一般做法：**

使用HashSet，放入40亿个数，占用16GB，然后再遍历查询0~4,294,967,295范围上，没出现过的数。但内存超出限制。

**有限资源的做法：**

使用位图统计$0\dots 2^{32}-1$范围的数，只需要声明一个$2^{32}$大小的bit数组，占用512MB。然后如果索引上的数存在，则位数组中值设为1。

bit数组可以用基础类型拼，比如arr = int[10] 可以表示一个320位。则获取index号的bit方法是，**index/32得到arr上的位置，index%32得到在这个数字的第几位**。

遍历$0\dots 2^{32}-1$范围的数，并设置位图中每一位的状态，再统计状态为0的位。

## 分段统计

上一题的进阶：内存限制为 3KB，但是只用找到一个没出现过的数即可

分析：

1. 3KB除以4，得到最大可以声明的整型数组的长度为768。找到离768最近且小于768的2的某次方，是512。
2. 将$0\dots 2^{32}-1$的范围均分为512份。每份负责的范围是$P={2^{32} \over {512}}=8388608$。
3. 申请一个数组arr=new int[512]，arr[0]存储在(0......8388608)范围上出现的不同数字有多少个；arr[1]存储在(8388608+1......8388608*2)范围上出现的不同数字有多少个.......，统计出每个范围的结果。
4. 就可以知道，不足8388608的范围，肯定有未出现的数字，只在这个小范围内查找。
5. 不满的小范围又可以继续下分，知道定位出没出现的数。

如果只允许有几个有限的变量：使用二分法，L=0，R=2^32-1，mid=(R-L)/2。

1. 左右部分的长度都为2^31，肯定有一部分不满，因为43亿的范围上，只有40亿的数。

分段统计思想：从范围做视角，所以内存3kb就可以分成512份，有限几个变量就只能二分。

## 哈希分流1

有一个包含100亿个URL的大文件，假设每个URL占用64B，

请找出其中所有重复的URL

分析：

1. 可以有失误率，就使用布隆过虑器。

2. 否则使用哈希分流。计算哈希值，分成满足限制内存的份数，或者不断的下分。

   因为哈希函数的相同输入一定有相同输出，所以重复的url肯定会分到同一份里。

## 分段+位图

32位无符号整数的范围是0~4294967295，

现在有40亿个无符号整数，可以使用最多1GB的内存，

找出所有出现了两次的数。

分析：

用1位表示$0\dots 2^{32}-1$的范围上的数是否出现，需要使用512MB。

用2位表示$0\dots 2^{32}-1$的范围上的数是否出现了两次，需要使用1GB。满足内存资源限制。

次数的状态表示：00（出现0次），01（出现1次），10（出现两次），11（出现3次及以上）。

进阶：

如果内存限制是小于1GB，则使用分段。每次遍历40亿个整数，只负责判断当前范围的数是否出现两次。

## 分段统计1

32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数

可以使用最多3K的内存，怎么找到这40亿个整数的中位数（是上中位数）？

分析：

中位数：排序后中间的数。（所以是范围上查找，第20亿个数，N/2）

不能是使用bfprt算法，因为需要装下40亿个整数的数组。

3kb只能申请arr = new int[512]，可以将$0\dots 2^{32}-1$的范围分为512份。统计每一份范围中，出现数的个数。

把每个范围的词频连加，直到累加和S等于或超过index=20亿，则说明index(中位数)一定在这个范围内。S-20亿得出中位数在当前范围的位置index"。

再递归求这个区间范围上第index"位置的数字。（不断下分）

## 堆合并结果

32位无符号整数的范围是0~4294967295，

有一个10G大小的文件，每一行都装着这种类型的数字，

整个文件是无序的，给你5G的内存空间，

请你输出一个10G大小的文件，就是原文件所有数字排序的结果

**分析：**

1. 使用大小适当长度为N的小根堆，节点包含值和其出现次数。
2. 遍历一遍大文件后，小根堆中可以正确统计出：最小的前N个数，和其出现次数。
3. 然后使用小根堆的数据生成文件。
4. 记录最大值M后，再将小根堆的空间释放。
5. 重新遍历一遍大文件，但<=M的数，不再统计。

## 哈希分流+堆

大文件里出现次数最多的前100名   或 

某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门Top100词汇的可行办法。

**分析：**

使用哈希分流，计算每一个小文件内的前100名。

每个小文件的第一名进行对比，取最大，就是整体数据的Top1。

<img src="images/image-20220222085910800.png" alt="image-20220222085910800" style="zoom: 67%;" />

可以用外排，遍历每个小文件的第一名，选完后删掉。

也可以使用大根堆，每个文件Top100，放在大根堆中，然后每个大根堆的堆顶再组成大根堆。**二维堆（堆上堆）**

最终大根堆每次弹出的数，就是TopN。