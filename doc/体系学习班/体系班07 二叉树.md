# 树形结构

定义：将一棵树进行180度大翻转，就成了数据结构中的树形结构。

1. 二叉树的每个节点，最多有两个分支。
2. 多叉树的每个节点，可以有任意个。

![img](https://img-blog.csdnimg.cn/20200105093213661.png)

实例：文件夹管理，就是树形结构，可以提高文件的查找效率。

## 基本概念

1. **根节点**：位于树中最顶端的节点就是整棵树的根节点。

2. **节点**：上图树中每个圆圆的就是节点。

3. **父节点和子节点**：一个节点分叉出来的就是该节点的子节点，而该节点就是这些子节点的父节点

4. **兄弟节点**：同属一个父亲的节点相互称为兄弟节点。

5. **子树，左子树、右子树**：一棵树中由很多小小的子树组成，如果一个节点的分枝有左右之分，那么一个节点的左分枝构成的子树则称为左子树，一个节点右分枝构成的子树为右子树

   1. 一棵树可以没有任何节点，称为空树
   2. 一棵树可以只有一个节点，也就只有根节点

6. **节点的度：**一个节点的子树的个数。

7. **树的度：**所有节点度中的最大值。

8. **叶子节点：**度为0的节点。

9. **非叶子节点：**度不为0的节点。

10. **层数：**根节点在第1层，根节点的子节点在第2层，以此类推（有些教材也从第0层开始算）

11. **节点的深度：**从根节点到当前节点的唯一路径上的节点总数

    **节点的高度：**从当前节点到最远叶子节点的路径上的节点总数。

    ![img](https://img-blog.csdnimg.cn/20200105105437146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjAxNzQz,size_16,color_FFFFFF,t_70)

    上图树中2号节点的深度为2，高度为3，因为从根节点到2号节点的唯一路径上的节点总数为2，从2号节点到最远叶子节点(13、14或15)的路径上的节点总数为3。

12. **树的深度**：所有节点深度中的最大值，很明显，该树的深度为4，从根节点到13、14或者15节点路径上的节点总数是4，而13、14、15**叶子节点**的深度是树中所有**节点深度中的最大值**。

    **树的高度**：所有节点高度中的最大值，很明显，该树的高度也为4，13、14或15是最远叶子节点，从根节点到这三个最远叶子节点的路径上的节点总数是4，而**根节点的高度**是树中所有**节点高度中的最大值。**

    **树的深度等于树的高度**。

# 二叉树

## 定义

- **每个节点的度最大为2（最多拥有两棵子树）**
- **左子树和右子树是有顺序的**
- **即使某节点只有一棵子树，也要区分左右子树**

```java
// 结构描述
class Node<V>{
    V value;
    Node<V> left;
    Node<V> right;
}
```

## 性质

- 非空二叉树的第i层，最多有$2^{i-1}\space(i\geq1)$节点
- 在高度为h的二叉树上最多有$2^h-1\space(h\geq 1)$个节点，即先计算每层最多节点，然后h层相加结果$2^{0} + 2^{1} + 2^{3} + ......+ 2^{h-1} = 2^{h} -1$（等比数列求和公式）
- 对于任何一课非空二叉树，如果叶子节点个数为n0，度为2的节点个数为n2，则有n0 = n2 + 1.

## 分类

### 真二叉树

（Proper Binary Tree)，所有节点的度都要么为0，要么为2。

### 满二叉树

（Full Binary Tree)，所有节点的度要么为0，要么为2，且所有的叶子节点都在最后一层。

假设满二叉树的高度为$h\space(h\geq1)$，那么

1. 第![i](https://private.codecogs.com/gif.latex?i)层的节点数量为：$2^{i-1}$
2. 叶子节点数量为：$2^{h-1}$
3. 总节点数量![n](https://private.codecogs.com/gif.latex?n)，$n = 2^{h} -1 = 2^{0} + 2^{1} + 2^{3} + ......+ 2^{h-1}$，$h=\log (n+1)$，log的底为2.

- 在同样高度的二叉树中，满二叉树的叶子节点数量最多，总节点数量最多
- 满二叉树一定是真二叉树，真二叉树不一定是满二叉树

### 完全二叉树

**(Complete Binary Tree)**：叶子节点只会出现在最后的2层，且最后一层的叶子节点都靠左对齐。

1. 简单来说，就是所有节点从上往下，从左往右依次排列。
   - 完全二叉树从根节点到倒数第2层是一棵满二叉树
   - 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树
   - 度为1的节点只有左子树
   - 度为1的节点要么是1个，要么是0个
2. 假设完全二叉树的高度为![h](https://private.codecogs.com/gif.latex?h)（![h\geq 1](https://private.codecogs.com/gif.latex?h%5Cgeq%201)），那么
   1. 至少有![2^{h-1}](https://private.codecogs.com/gif.latex?2%5E%7Bh-1%7D)个节点（![2^{0} + 2^{1} + 2^{3} + ......+ 2^{h-2}+1](https://private.codecogs.com/gif.latex?2%5E%7B0%7D%20&plus;%202%5E%7B1%7D%20&plus;%202%5E%7B3%7D%20&plus;%20......&plus;%202%5E%7Bh-2%7D&plus;1)）![img](https://img-blog.csdnimg.cn/20200105120623331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjAxNzQz,size_16,color_FFFFFF,t_70)
   2. 至多有![2^{h} -1](https://private.codecogs.com/gif.latex?2%5E%7Bh%7D%20-1)个节点（![2^{0} + 2^{1} + 2^{3} + ......+ 2^{h-1}](https://private.codecogs.com/gif.latex?2%5E%7B0%7D%20&plus;%202%5E%7B1%7D%20&plus;%202%5E%7B3%7D%20&plus;%20......&plus;%202%5E%7Bh-1%7D)，满二叉树）![img](https://img-blog.csdnimg.cn/20200105120649620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjAxNzQz,size_16,color_FFFFFF,t_70)
   3. 总节点数量为 n，![2^{h-1}\leq n < 2^{h}](https://private.codecogs.com/gif.latex?2%5E%7Bh-1%7D%5Cleq%20n%20%3C%202%5E%7Bh%7D)，因此![h-1\leqslant \log n< h](https://private.codecogs.com/gif.latex?h-1%5Cleqslant%20%5Clog%20n%3C%20h)，推出![h = floor(\log n) + 1](https://private.codecogs.com/gif.latex?h%20%3D%20floor%28%5Clog%20n%29%20&plus;%201)，floor为向下取整，另外ceiling是向上取整。
3. 如果一棵完全二叉树有768个节点，求叶子节点的个数
   1. 令二叉树中叶子个数为L，只有一个孩子的节点数为S， 有两个孩子的节点数为D，所有节点数位n，则有n=L+S+D 
   2. 每一个度为2的节点都指向2个节点，每一个度为1的节点指向1个节点，而仅仅只有根节点1个没有节点指向它，则有n=2D+S+1
   3. 结合两个等式：L+S+D=2D+S+1 => D=L-1
   4. n=2D+S+1，D=L-1 => 2L+S=769
   5. 根据完全二叉树的性质，**度为1的节点的个数至多为1**，可知S=0或S=1， 从2L+S=769可知 S=1。
   6. 则2L=768，L=384

### 平衡二叉树

**平衡二叉查找树**：简称平衡二叉, 平衡树(Balance Tree，BT) , 英文名也称为 AVL 树, 具有如下几个性质：

1. 可以是空树。
2. 假如不是空树，任何一个节点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。

平衡之意，如天平，即两边的分量大约相同。

### 搜索二叉树

 二叉搜索树，二叉排序树(Binary Search Tree) 具有如下几个性质：

1. 可以是空树。
2. 若它的左子树不空，则左子树上所有节点的最大值小于它的根节点的值； 
   若它的右子树不空，则右子树上所有节点的最小值大于它的根节点的值； 
   它的左、右子树也分别为二叉排序树

**在搜索二叉树中, 多个相同的值放在同一个节点中, 左子树或右子树可以为空**.

## 先、序、后序遍历

1. 先序：任何子树的处理顺序都是，先头节点、再左子树、然后右子树
2. 中序：任何子树的处理顺序都是，先左子树、再头节点、然后右子树
3. 后序：任何子树的处理顺序都是，先左子树、再右子树、然后头节点

**递归实现**

1. 理解递归序  (一个节点)

2. 先序、中序、后序都可以在递归序的基础上加工出来  

3. 第一次到达一个节点就打印就是先序、第二次打印即中序、第三次即后序  

**非递归实现**

1. 任何递归函数都可以改成非递归  
2. 自己设计压栈的来实现  
2. 工程上不能出现递归, 因为递归在不知道层数的情况下, 使用的系统栈是有限制的, 一般200Mb. 会报错. 自己设计压栈使用内存空间,足够大.

## 题目

- 二叉树某一节点X, 其先序的左侧集合A与后序的右侧集合B的交集, 是其所有的祖先节点.  

  证明:  

  头左右: 先序的左侧集合A包含其父节点和其左子树的节点,  

  左右头: 后序的右侧集合B包含其父节点和其右子树的节点.

  分析A和B的交集：

  - X的祖先节点在交集中
  - X的孩子节点不在交集中.  
  - X节点不在交集中.  
  - X做为左树姿态下的右兄弟们, 在先序的右侧集合中
  - X做为右树姿态下的左兄弟们, 在后序的左侧集合中

- 递归方式实现二叉树的三序遍历

- 非递归方式实现二叉树的三序遍历

- 实现二叉树的按层遍历

  1）其实就是**宽度优先遍历，用队列按层的顺序存储节点**。

  2）可以通过设置flag变量的方式，来发现某一层的结束

  因为队列弹出当前层的节点，都会压入下一层的节点。

- 求二叉树最宽的层有多少个节点

  二叉树的按层遍历，

  使用有限的变量，建立每一层结束的机制。

  **当前层的最右节点的子节点，是下一层的最右节点。**

  使用HashMap存储每一节点的深度，来用节点深度和当前深度判断是否同一层

- 二叉树的序列化和反序列化

  节点为null, 也加入序列中.

  1）先序方式序列化和反序列化

  ​	1）可以用先序或者后序或者按层遍历，来实现二叉树的序列化

  ​    2）用了什么方式序列化，就用什么样的方式反序列化

  ​    3）中序遍历无法实现序列化和反序列化, 因为有岐义, 不同的两棵树，可能得到同样的中序序列，即便补了空位置也可能一样:  

  ```java
       * 比如如下两棵树 2(1(null,null), null).  1(null, 2(null, null))
       *         __2
       *        /
       *       1
       *       和
       *       1__
       *          \
       *           2
       * 补足空位置的中序遍历结果都是{ null, 1, null, 2, null}
  ```

  2）按层方式序列化和反序列化

- 将 N 叉树编码(序列化)为二叉树
  https://leetcode-cn.com/problems/encode-n-ary-tree-to-binary-tree

  设想将N 叉树的一个节点的所有孩子节点, 放入二叉树对应**节点的左子树的右边界上**. 

  使用深度优先遍历.

  **每一个多叉树都可以转为唯一的二叉树**

  反序列化时, 如果**一个节点没有左树节点, 则没有孩子节点**. 
  
  时间复杂度:  O(N)
  
- 如何设计一个打印整棵树的打印函数(少见)

  向左翻转90度的满二叉树，使用中序遍历

- 二叉树中指定节点X的后继节点 (后继节点: 中序遍历中, X节点的下一个节点就是X的后继节点)

  ```java
  //二叉树结构如下定义：
  Class Node {
  	V value;
  	Node left;
  	Node right;
  	Node parent;
  }
  ```

  方法1:  时间复杂度O(N), 中序遍历, X的右侧第一个.

  方法是:  时间复杂度O(K),  K是X到其后继节点的距离, 从结构上分析, 一个节点和它的后继节点的关系.

  1. X有右子树, 后继就是右子树的最左; 
  1. X没有右子树, 向上查找, 直到子节点是父节点的左孩子, X做为左树的最右, 后继就是该子树的头.

- 从上到下打印对折纸条所有折痕的方向:  

  请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。 

  给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。 

  例如:N=1时，打印: down N=2时，打印: down down up 
  
  规则: 1. 头节点是凹着的, 2. 所有左子树的头节点都是凹 3. 所有右子树的头节点都是凸的
  
  方法: 每次对折, 上一次的每个折痕, 都会依次产生一个下折痕和一个上折痕.(二叉树的中序遍历)
  
  节点个数:2^N-1, 空间占用O(N) N为对折N次(树的高度). 最终用递归打印出想象中的二叉树.

# 二叉树的递归套路

可以解决面试中绝大多数的二叉树问题尤其是**树型DP(在树上做动态规划)**问题,

本质是利用递归遍历二叉树的便利性(**递归后序遍历, 每个节点最多到3次**), 时间复杂度O(N), 是最优解

优点: 

1. 思想提醒: 想以X为头时,目标怎么实现. 实现手段是左右树要简单信息(常数时间内可得到, 加工信息也是常数时间), 列可能性, 有X情况和没有X的情况.
2. 高度模板化.  Info, process,  节点为null时返回空树是否好设置, 左右树的处理.

解题思路:

1. 假设以X节点为头，假设可以向X左树和X右树要任何信息 

2. 在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要） 

3. 列出所有可能性后，确定到底需要向左树和右树要什么样的信息 

4. 把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S

5. 递归函数都返回S，每一棵子树都这么要求 

6. 写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息 

## 深度实践

给定一棵二叉树的头节点head，

- 题目1: [[判断二叉树是不是平衡二叉树]]

- 题目2: [[判断二叉树是不是满二叉树]]

- 题目3: [[判断二叉树是不是搜索二叉树]]

  - 左树要求返回二个参数:是否为搜索二叉树, 最大值.
  - 右树要求返回二个参数:是否为搜索二叉树, 最小值.
  - 递归中,左右要求不一样, 求全集.

- 题目4: [[二叉树中最大的二叉搜索子树的大小]]

- 题目5: [[二叉树中最大的二叉搜索子树的头节点]]

- 题目6: [[判断二叉树是不是完全二叉树]]

  - 用二叉树的递归套路来解这个题

- 题目7: [[二叉树上两个节点的最低公共祖先]]

- 题目8: [[任何两个节点之间都存在距离，求X子树的两个节点的最大距离]]

  递归对左右子树操作的两个参数: 树的高度和最大距离.

  - X左树的最大距离. 与X无关: 
  - X右树的最大距离, 与X无关: 
  - X的左树最远**(左树高度)**到X的右树最远**(右树高度)**的距离+1. 与X有关: 

- 题目9: [[派对的最大快乐值]]

  ```java
  // 多叉树：员工信息的定义如下:
  class Employee {
      public int happy; // 这名员工可以带来的快乐值
      List<Employee> subordinates; // 这名员工有哪些直接下级
  }
  ```

  描述：

  - 公司的每个员工都符合 Employee 类的描述。
  - 整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。
  - 树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 
  - 叶节点是没有任何下属的基层员工(subordinates列表为空)，
  - 除基层员工外，每个员工都有一个或多个直接下级。

  这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：

  1. 如果某个员工来了，那么这个员工的所有直接上下级都不能来， 如选了boss 经理不能来，但员工可以来

  2. 派对的整体快乐值是所有到场员工快乐值的累加

  3. 你的目标是让派对的整体快乐值尽量大
  4. 给定一棵多叉树的头节点X，请返回派对的最大快乐值。

  分析：二叉树的树形DP问题：两种情况：X不来和来的情况。
