## 比较器

1. 比较器的实质就是重载比较运算符 

2. 比较器可以很好的应用在特殊标准的排序上 

3. 比较器可以很好的应用在根据特殊标准排序的结构上

4.  写代码变得异常容易，还用于范型编程 

任何**比较器的统一约定**，即如下方法：

```java
@Override
public int compare(T o1, T o2) ;

// 返回负数的情况，就是o1比o2优先的情况
// 返回正数的情况，就是o2比o1优先的情况
// 返回0的情况，就是o1与o2同样优先的情况
```

有空值null的情况：

1. null小于非null。

2. 当两个对象均为空时，它们被视为相等。

3. 当指定的比较器为null时，返回的比较器将所有非null值视为相等。

## 堆结构

1. 堆结构就是用数组实现的完全二叉树结构

   想像中的二叉树.

   任何一个i位置, 它的**左节点索引位置是2*i+1, 右节点是2\*i+2, 父节点是(i-1)/2.**

2. 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆

3. 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆

4. 堆结构的heapInsert向上调整,与heapify向下调整操作

   若堆中有index位置的数错误,, 或修改堆中元素的值 调用一次heapInsert和heapify, 两个方法只会执行一个，时间复杂度是logN，堆还是大根堆

   操作的时间复杂度是O(logN), 移动的步骤数是和**堆的高度相关logN**. (heapify只向一侧沉), 

5. 堆结构的增大和减少 

6. 优先级队列结构，就是堆结构 

**语言提供的堆结构 vs 手写的堆结构**

1. 取决于，你有没有动态改信息的需求！

2. 语言提供的堆结构，如果你动态改数据，不保证依然有序

3. [[手写堆]]，因为增加了对象的位置表，所以能够满足动态改信息的需求

## 堆排序

1. 先让整个数组都变成大根堆结构，建立堆的过程:       
   1. 从上到下的方法，**时间复杂度为O(N \* logN)**   

      加入N个数, **最大高度时才是logN**,, 每一次加数的时间复杂度logN是变化的,动态增加的. :

      如:  log1+log2+log3......logN， 粗暴的认为是O(N \* logN)，（存疑）
   
      动态的操作如何估计复杂度: 使用数据量增加常数(扩倍)法：N个数和2N个数的复杂度一样。（忽略常数项）

      1.  N个数放入堆中得到复杂度上限：O(N*logN)
      2. 2N个数放入堆，先是N个数入堆，高度是logN，则得到复杂度下限O(N*logN)
      3. 上限，下限一样，则时间复杂度为O(N \* logN)   
   
   2. 从下到上的方法，时间复杂度为O(N)   
   
      满二叉树或非满二叉树时，最下层叶子节点差不多是N/2个或N/2+1，
   
      从下到上的操作数为：
   
      第一层：有N/2个节点，因为是叶子节点，每个节点执行heapify为1次。
   
      第二层：有N/4个节点，每个节点往下沉只有一层，所以每个节点执行heapify为2次。
   
      ............... 可得**等比数列求和公式**(q=0.5)：**错位相减法**。 一定收敛于O(N)
      $$
      \begin{align}
      S(N) &= \frac N2 *1+\frac N4*2+\frac N8*3+\dots\frac{N}{2^n}*N\\
      2*S(N) &= N*1+\frac N2*2+\frac N4*3+\dots\frac{N}{2^{n-1}}*N \\
      S(N) &= 2S(N)-S(N) \\
       &=N+\frac N2+\frac N4 +\dots\frac{N}{2^{n-1}}*N \\
       &=\frac{1-q^n}{1-q} * N   (q=\frac 12)
       \end{align}
      $$
   
   3. 区别是：完全二叉树是一个三角形，数的宽度是越来越大。
   
      从上到下：大量节点是高度增加之后加上去的，O(N*LogN)。 
   
      从下往上：大量的节点是层数少的，少量的节点是层数高的。O(N),   
   
      经典的堆结构需要heapinsert, heapify,需要一个个数的增加，用临时的数来建堆，只能使用从上往下建堆
   
      堆排序中，一次得到所有数。只需要有heapify，使用从下往上建堆。
   
2. 把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N \* logN)   

3. 堆的大小减小成0之后，排序完成   

4. 额外空间复杂度O(1)

**题目**

- [[相对几乎有序数组排序]]，已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。

  请选择一个合适的排序策略，对这个数组进行排序。  

  **使用heapSize=K的小根堆**。

- 最大线段重合问题：给定很多线段，每个线段都有两个数[start, end]，表示线段开始位置和结束位置，左右都是闭区间

  规定：

  1）线段的开始和结束位置一定都是整数值

  2）线段重合区域的长度必须>=1

  返回线段最多重合区域中，包含了几条线段

  **思路：**

  - 重合的区域一定包含两个整数之间的小数，如1~2包含0.5. 包含0.5的线段，在1~2之间重合。

  - 多个线段重合,则重合区域的左边界必定是其中一个线段的左边界.

    所以可以通过计算每一个线段的左边界为重合区域的左边界时, 线段的重合数.

  **用堆的实现的解题流程：**
  
  - 线段数组从小到大排序,并遍历.
  - 若重合区域用当前线段的开始位置做左边界, 有多少线段是穿过相同的左边界住右沿续
  - 小根堆中记录之前线段的结束位置与当前线段的重合, 则结束位置必须大于线段开始位置
  - 所以若小根堆中, 有小于等于线段开始位置的值, 则弹出.
  - 将结束位置的数放入小根堆中, 小根堆中有几个数, 就是这个线段重合的个数.
  - 最大的就是最大线段重合数.
  

## 改写堆

系统提供的堆无法做到的事情：

1. 已经入堆的元素，如果参与排序的指标方法变化，

   系统提供的堆无法做到时间复杂度O(logN)调整！都是O(N)的调整！

2. 系统提供的堆只能弹出堆顶，做不到自由删除任何一个堆中的元素，

   或者说，无法在时间复杂度O(logN)内完成！一定会高于O(logN)。 

3. 根本原因：**无反向索引表**， 无法通过给定的元素，直接定位其位置，

   只能遍历查找O(N)，然后再heapify-O(logN).

Java偏应用，大部分的使用场景都不需要调整已入堆的元素，所以为了节省资源，没有反向索引表。

但像C++的一些委员会提供的包中，有些堆是有反向索引表的。

**改写步骤**：

1. 建立反向索引表

2. 建立比较器

3. 核心在于各种结构相互配合，非常容易出错
4. ArrayList的get和set都是O(1)
5. 修改堆中元素的值 通过调用heapInser和heapify, 两个方法只会执行一个，时间复杂度是logN，堆调整完毕。

### 题目

前提条件：

1. 给定一个整型数组，int[] arr；和一个布尔类型数组，boolean[] op
2. 两个数组一定等长，假设长度为N，arr[i]表示客户编号，op[i]表示客户操作
3. arr = [ 3  ,  3  ,  1  , 2,   1,   2,   5…
4. op = [ T  ,  T,   T,   T,   F,   T,    F…

依次表示：3用户购买了一件商品，3用户购买了一件商品，1用户购买了一件商品，2用户购买了一件商品，1用户退货了一件商品，2用户购买了一件商品，5用户退货了一件商品…

一对arr[i]和op[i]就代表一个事件：

1. 用户号为arr[i]，op[i] == T就代表这个用户购买了一件商品, op[i] == F就代表这个用户退货了一件商品
2. 现在你作为电商平台负责人，你想在每一个事件到来的时候，都给购买次数最多的前K名用户颁奖。
3. 所以每个事件发生后，你都需要一个得奖名单（得奖区）。

得奖系统的规则：

1. 如果某个用户购买商品数为0，但是又发生了退货事件，

   则认为该事件无效，得奖名单和上一个事件发生后一致，例子中的5用户

2. 某用户发生购买商品事件，购买商品数+1，发生退货事件，购买商品数-1

3. 每次都是最多K个用户得奖，K也为传入的参数 

   如果根据全部规则，得奖人数确实不够K个，那就以不够的情况输出结果

4. 得奖系统分为得奖区和候选区，任何用户只要购买数>0，一定在这两个区域中的一个

5. 购买数最大的前K名用户进入得奖区，

   在最初时如果得奖区没有到达K个用户，那么新来的用户直接进入得奖区

6. 如果购买数不足以进入得奖区的用户，进入候选区

7. 如果候选区购买数最多的用户，已经足以进入得奖区，

   该用户就会替换得奖区中购买数最少的用户（大于才能替换），

   如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户

   如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户

8. 候选区和得奖区是两套时间，

   因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有

   从得奖区出来进入候选区的用户，得奖区时间删除，进入候选区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i）

   从候选区出来进入得奖区的用户，候选区时间删除，进入得奖区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i）

9. 如果某用户购买数==0，不管在哪个区域都离开，区域时间删除，

   离开是指彻底离开，哪个区域也不会找到该用户

   如果下次该用户又发生购买行为，产生>0的购买数，

   会再次根据之前规则回到某个区域中，进入区域的时间重记

请遍历arr数组和op数组，遍历每一步输出一个得奖名单

public List<List<Integer>> topK (int[] arr, boolean[] op, int k)

## 补充

可以通过题目的数据规模, 推理时间复杂度符合的算法, 如在牛客网.

代码的指令条数在10^8~10^9内, 代码执行时间:

1. C/C++ 1-2S
2. Java/C#(有虚拟机) 2-4s
3. 脚本语言 2-4s

