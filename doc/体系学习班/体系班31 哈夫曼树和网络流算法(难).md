# 哈夫曼树

已知一篇文章中的出现字符的频次【a(16)，b(29)，c(2)，d(1)，e(0)】，求用01表示的最少个数。

1. 类似于体系班8贪心算法中的分金条问题，用小根堆，

   每次弹出最小的两个数，频次相加后再放入堆，直到堆的大小为1.

2. 从下往上组合成一个二叉树：e+d=1，1+c=3，3+a=19，19+b=48.

   所以：b=1，a=01，c=001，d=0000，e=0001

3. 再把01码编成byte文件，文章大小最小，传输量最低。

解码方式：

1. 根据词频表，生成二叉树（或前缀树），
2. 然后byte文件中，从左往右，依次从二叉树的根节点往下滑，到叶子节点时结束，
3. 在字典中查找对应的字符。

特殊情况

1. 最后一个byte对不齐问题（不满）

   多增加一个byte，记录最后一个byte到那个位置截止。

2. 整篇文章都是同一个字符，词频表只有一条数据。

   需要特殊处理，编码为0。因为一个字符无法补全二叉树的叶节点（一个节点的左右节点有一个为空）

# 网络流算法

最大网络流，一定要指明一个源点和目标点，以及每条线路的承载量。下图中从A到D的最大网络流为130.

![image-20220328003242973](D:\GitHub\Algorithm\doc\体系学习班\images\image-20220328003242973.png)

不能直接用深度优先遍历，会因为选边的顺序算不出正确答案。如下图，每条线路的承载量都为50，使用深度优先遍历若是ABCD路线先选，则会将沿途的承载量设为0，然后A到D的最大网络流是50。但正确的是100.

![image-20220328003359954](D:\GitHub\Algorithm\doc\体系学习班\images\image-20220328003359954.png)

最大网络流Dinic算法的三个优化：

1. **补反向边**：隐含路线的建立（减少多少，反向边增加多少。），可以解决反悔的问题。

   如果你是正常线路的话，增加反向边不会增大答案，但是会因此让什么让已经错失的可能性给扳回来

   ABCD得到50后，补i反向边，则有ACBD路线，也得50。有正确答案100.

   ![image-20220328073318878](D:\GitHub\Algorithm\doc\体系学习班\images\image-20220328073318878.png)

2. **高度数组：**

   1. 通过宽度优先遍历，得到高度数组：【A(0)，B(1)，C(1)，D(2)】,可以让每一步下推得代价，尽量的低。
   2. 进行深度优先遍历dfs时，高度数组可以避免反悔（来回走）的问题。
   3. 因为B，C高度一样，所以不走B到C的路线，直接B到D。

3. **支路数组 ：**

   1. 记录着每一个点走到了哪条支路。
   2. 如果我们有一个数组记录着某一个点之前哪些线路用过了，  直接从没用完的边继续试







