# 前缀树

名称：prefix tree 或 Trie

实现过程:

1. 单一字符串中,字符从前到后加到一棵多叉树上.
2. 字符放在路上, 节点上有专属的数据项(常见的是Pass和End, 子节点数组)
3. 所有样本都这样添加, 如果没有路就新建, 有就复用.
4. 沿涂节点的pass值增加1, 每个字符串结束时来到的节点end值加1.

作用: 可以完成**字符串前缀**相关的查询.

结构功能：

```html
1）void insert(String str)            添加某个字符串，可以重复添加，每次算1个
2）int search(String str)             查询某个字符串在结构中还有几个
3) void delete(String str)           删掉某个字符串，可以重复删除，每次算1个
4）int prefixNumber(String str)       查询有多少个字符串，是以str做前缀的
```

## 实现方式

使用底层节点是为空，来标记路径是否存在。

两种方式:

1. 固定数组实现前缀树
2. 哈希表实现前缀树


拓展:

- 目前节点只是封装了p值跟e值, 可以封装别的更丰富的信息来解决某些问题
- 如果一些题带有前缀查询特征, 前缀树就可以通过每个节点增加更多信息支持本题目快速解决

# 桶排序

思想：将每个数按照一定的规则，放入准备好的多个容器中，再从容器中取出，完成排序。

1. 都是不基于比较的排序。
2. 时间复杂度O(N)，额外空间复杂度O(M)
3. 应用范围有限，需要样本的状况满足桶的划分。**样本数据是有限制的。**

计数排序和基数排序：

1. 一般来讲，计数排序要求，样本是有限的正整数，且范围比较窄

2. 一般来讲，基数排序要求，样本是10进制的正整数（可改写为负数）
3. 一旦要求稍有升级，改写代价增加是显而易见的

比较：

1. 应用范围：基于比较通用性好，不基于比较的排序，受数据限制
2. 时间复杂度：基于比较的排序，O(N*logN)是极限，而不基于比较的排序，在数据状况受到限制的情况下，O(N)是极限。

