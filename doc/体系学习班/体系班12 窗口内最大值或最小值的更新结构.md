# 滑动窗口

滑动窗口是一种想象出来的数据结构：

1. 滑动窗口有左边界L和有边界R
2. 在数组或者字符串或者一个序列上，记为S，窗口就是S[L..R]这一部分
3. 任何时刻，L往右滑意味着**一个样本出了窗口**，R往右滑意味着**一个样本进了窗口**
4. L和R都只能往右滑，不能回退，且L不能在R右边

**作用**

滑动窗口、首尾指针等技巧，说白了是一种求解问题的流程设计。 

假设维持了一个窗口, 看能不能把它维持住, 维持不住不要用

# 滑动时窗体的最大(小)值

窗口不管L还是R滑动之后，都会让窗口呈现新状况，

如何能够更快的得到窗口当前状况下的最大值和最小值？

1. 简单做法：遍历当前窗口范围内的数。
2. 找到一种数据结构结构，可以尽快的更新出窗口内最大值或最小值。最好平均下来复杂度能做到O(1)，【**利用单调双端队列**！】

## 窗口右移的更新策略

示例：[6，4，2，3，5，7，7，5]

- 双端队列：头部到尾部的索引所对应的值，严格从大到小。
- 在头部和尾部都可以进和出【时间复杂度O(1)】
- 头部就是最大值的索引。初始L和R= -1.

当R往右移动时，双端队列的更新策略

1. R=0...2， [(0)6，(1)4，(2)2]**数组的索引值**进入队列尾部中，
2. R=3时，3比最小值2要大，队列中弹出2，尾部再加入3.  【(0)6，(1)4，(3)3】
3. R=4时，队列中弹出4，3，尾部再加入5.   【(0)6，(4)5】
4. R=5时，队列中弹出6，5，尾部再加入7.   【(5)7】
5. R=6时，**与队列中最小重复**，队列弹出7（队列中必须比新加入的大）， 尾部再加入7。【(6)7】

当L往右移动时，L=1，**头部弹出过期的索引(1)，**然后当前窗口的最大值，就是队列头部下标所指向的值。

总结

1. 队列中要弹出小于当前位置的数的原因：因为窗口缩小只能是L往右移，所以当前的索引大于之前加入节点的索引，缩小造成最大值过期的时间肯定最晚，所以队列小于当前位置的数都没有用了。
2. 含义：如果此时依次让窗口缩小，队列中哪些位置的数，会依次成为窗口的最大值。

## 为什么比遍历好：

1. 假设L，R会划过数组N中所有的数字，每个位置至多进入1次，出去1次，出去的数就不再找回。
2. 窗口在运动的过程中，双端队列更新的总代价是O(N)，平均下来每一个数更新的是O(1)。
3. 每一次获得的最大值，就是双端队列头部的**索引值**所对应的数组中的值，查询O(1)。

# 题目

## 滑动窗口最大值

假设一个固定大小为W的窗口，依次划过arr，

返回每一次滑出状况的最大值

例如，arr = [4,3,5,4,3,3,6,7], W = 3，返回：[5,5,5,4,6,7]

**分析**

arr长度为N，窗口大小W=3，窗口滑动能收集到N-W+1个结果。

两种实现方法：暴力遍历和窗口最大值的更新结构。

## 整形数组中子数组达标的个数

给定一个整型数组arr，和一个整数num

某个arr中的子数组sub，如果想达标，必须满足：sub中最大值 – sub中最小值 <= num，

返回arr中达标子数组的数量（子数组一定是连续的）

**分析**

**从0出发，有多少个符合条件的子数组，**

**从1出发...**

**从N出发，有多少个符合条件的子数组，**

暴力方法：

1. 枚举所有子数组，子数组的范围L[0,N-1]，R[L,N-1]，
2. 子数组是L和R的组成的二维表，可由两个嵌套循环得出。
3. 每个范围进行遍历，得到最大值和最小值，达标总数量加1.
4. 时间复杂度O(N^3)

推论：不达标的子数组扩大后也不达标，达标的子数组缩小后都达标

1. 如果一个子数组达标，则其所有子数组都达标。

   因为[L...R]max - [L....R]min <= num ，子数组的最大值只能由max变小，最小值只能由min变大，max>min且达标

2. 如果一个子数组不达标，则L往左扩也不达标，R往右扩也不达标。


使用窗口内最大和最小值的更新结构，将时间复杂度优化为O(1)

1. 窗口的范围[L，R) 左开右闭，所以[0，0)无数据。
2. 使用两个双端队列，维护最大值和最小值的更新。
3. 初始L=R=0， R往右移动，如果[L,R]不达标，则[0,R-1]的所有子数组都达标，达标总数量加R-0，
4. 然后移动L=1，R可以继续往右移动，判断是否达标。
5. 时间复杂度O(N)，L,R不回退，窗口更新最大，最小值，只过N个数。

## 加油站的良好出发点问题

两个数组，一个是加油站存储油数组，一个是到达目的地耗费油数组。

返回从每个加油站出发，可以绕一圈的结果数组。（只能按顺序行驶）

**示例：**

gas[1，1，3，1]  cost[2，2，1，1]   0-a，1-b，2-c，3-d

a号加油站有1单位油，跑到b号加油站需要消耗2单位油

b号加油站有1单位油，跑到c号加油站需要消耗2单位油

c号加油站有3单位油，跑到d号加油站需要消耗1单位油

d号加油站有1单位油，跑到a号加油站需要消耗1单位油

最后从每个加油站出发，能否跑完一圈的的结果是：[F，F，T，F]

**分析**

**从0号加油站出发，能否绕一圈，**

**从1号加油站出发......**

**从N号加油站出发，能否绕一圈。**

先进性题目简化：

1. 存储油的数组减去耗油数组得到：arr[-1，-1，2，0]，（当前位置到下一位置后，剩余的油）
2. 只要是当前位置和之后位置的累加和>=0，则说明能跑完一圈。

暴力解：O(N^2)。每个位置作为出发点，遍历一遍。（循环数组的遍历）

使用窗口内最大和最小值的更新结构：

示例：

到下一个位置剩余油的数组：[-2，-3，4，-2，6，-1]

**加工出一个长度为2倍的复合的前缀和Sum**，[-2，-5，-1，-3，3，2，0，-3，1，-1，5，4]

从0出发，依次累加和是：[-2，-5，-1，-3，3，2]，因为有负值，所以不是良好出发点

从1出发，依次累加和是：[-3，1，-1，5，4，2] ，因为有负值，所以不是良好出发点

发现规律：Sum数组中，从[1,6]范围内的数减去0位置的数-2，就可以得到从1出发的累加和数组。

计算两倍长度的数组的原因：**原始数组中，从任一位置出发，其走完一圈的累计和数组，都可以在这个长数组中计算出来**

在Sum长数组中，使用一个长度为6的窗口。

1. [0,5]范围的窗口，最小值处理后是-5-0，右移后[1,6]范围上窗口的最小值处理后是-5 - (-2) = -3，所以0和1都不是良好出发点。
2. [2,7]范围的窗口, 最小值处理后是-3 - (-5) = 2,  大于0，所以是良好出发点。
3. 无法绕完一圈：累计和数组有负数，或者数组的最小值为负数。

解题规律：

1. 一个问题的求解过程(思路和流程)，是否和窗口的运动轨迹相似（从0,1,2.....出发到最后的情况）
2. 难点在于，加工出一个2倍长度的复合前缀和数组，每次窗口移动，还原出原始的前缀和数组。
3. 累加和范围的L和R(**左右边界**)不会退，则和窗口运动轨迹有相似性。
4. 往窗口的最大最小值的更新上靠，就如原始的前缀和数组的最小值大于等于0，则说明可以平安到达所有的加油站。

## 货币数组组成面值的最少货币数

arr是货币数组，其中的值都是正数。再给定一个正数aim。

每个值都认为是一张货币，

返回组成aim的最少货币数

注意：因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了

**分析**

可以使用动态规划，是从左到右的尝试模型，是否选择当前货币，剩下的值需要最少几张。

简化：整理出面值数组，和张数数组，再尝试。

和上一课中的题目的区别：

1. 之前的题目是位置依赖关系是**累加和(组成aim的方法数，可以省掉枚举行为)，**

   ？是当前位置的值，X是临近位置的值，张数限定为3，X = b+0  +  c+1   +  d+2    ? = a+0  +  b+1   +   c+2

   则？=  a+0  +  x+1  - (d+2)

2. 而这个题目的位置依赖是一个窗口**范围内的最小值，所以不能直接用临近位置代替。**

   ？是当前位置的值，X是临近位置的值，张数限定为3，X = Min(b+0，c+1，d+2)    ? = Min(a+0，b+1，c+2)   无法直观的使用临近位置进行计算。

使用窗口最小值的更新模型，优化枚举行为：

1. 使用张数限定窗口大小，然后从0开始往右滑动。很快得出每个位置的最小值

   根据张数限定，生成多个窗口，窗口范围就是当前数值的张数。

2. 数据进入窗口的规则：队列中X元对应a张，一个Y元对应的b张要进入队列：则b要与a+(Y-X)/面值 进行比较。

   **补偿合适的张数的计算规则:  (Y-X)/面值**

3. 每行使用分组填充，示例：aim=30， 面值为7元，先填[0的组]0，7，14，21，28 ;再填[1的组]1，8，15，22，19.......  组数要小于Min（钱数加1，或 当前面值）

4. 队列中最小值的使用和进入，都需要在选择的值的基础上，再加上**补偿**的值，因为队列中存储的是dp表中rest的索引值，

补偿示例：面值是3元， 队列中存储的是{19元(d)}, ?位置的数，就是队列中的最小值对应的d，再加上补偿值3 (28-19/3)

| 19元  | 22    | 25    | 28    |
| ----- | ----- | ----- | ----- |
|       |       |       | ?     |
| d(+3) | c(+2) | b(+1) | a(+0) |

时间复杂度：

1. 没压缩时的版本dp1：O(N*aim)
2. 压缩后的版本dp2：O(M*aim)，重复面值越多，优化越大。

优化策略：

1. 数据压缩。
2. 窗口最小值的更新结构

## 子数组长度不超过M的最大累加和

给定一个数组arr，和一个正数M，

返回在arr的子数组在长度不超过M的情况下，最大的累加和

**分析：**

滑动窗口解法：（窗口内的最大值的更新结构）

1. 类似加油站问题。

2. 前缀和数组，再计算每次窗口滑动的前缀和的最大值，就是以index位置开头的子数组，长度不超过M的最大累计和是多少。

3. 三步：

   初始化窗口（右扩）的最大值，

   移动窗口时的最大值，

   收缩窗口（左收）的最大值，

   窗口中最大值就是一种可能性。所有可能性中，最大的值就是结果。