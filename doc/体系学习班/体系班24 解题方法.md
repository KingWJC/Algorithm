# 对数器找规律

暴力递归和对数器是通用技巧

1. 若题目中，输入参数简单，只有一个实际参数

2. 要求的输出参数简单，且只有一个。

3. 用暴力尝试，执行一段连续的输入值，打印结果，寻找抽象规律，并优化code。

   **算法有两大类：明确知道怎么算，和 知道怎么尝试（递归）**

# 根据数据规模猜解法

ACM的第一个需要掌握的技巧

1. 时间复杂度分析
1. 结论：C/C++,1秒处理的指令条数为10的8次方，Java等语言，1-4秒处理的指令条数为10的8次方。
3. 观察：根据数据规模，选择合适的时间复杂度的算法。

# 分治的应用场景

1. 数据量整体做尝试的可能性太多，跑不完
2. 数据分成多个块（常见是两块）之后，各个块的可能性不多。
3. 合并多个块的信息的整合过程并不复杂。

# 题目

## 至少使用多少袋子装苹果

小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量。

1）能装下6个苹果的袋子

2）能装下8个苹果的袋子

小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，且使用的每个袋子必须装满。

给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1

**分析**

先尽量用能装下8个苹果的袋子装，需要几个袋子？

剩下的用能装下6个苹果的袋子装，需要几个袋子？

若装不满，则少用1个能装下8个苹果的袋子，再去尝试用能装下6个苹果的袋子装。

暴力尝试，并用1-100连续的数，测试其结果，然后分析规律。

1. 奇数一定不符合，返回-1

2. 从18开始，每8个数为1组。

   18-25 8个数 偶数返回3，奇数返回-1

   26-33 8个数 偶数返回4，奇数返回-1

3. [18,....) 之后的结果：(apple-18)/8 + 3

## 牛羊吃N份青草谁会赢

给定一个正整数N，表示有N份青草统一堆放在仓库里

有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草

不管是牛还是羊，每一轮能吃的草量必须是：

1，4，16，64…(4的某次方)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             

谁最先把草吃完，谁获胜

假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定

根据唯一的参数N，返回谁会赢

**分析**

递归尝试：

1. 每一轮选择，能吃的草量，在【1】到【4^n<N】范围上进行尝试。

2. 每次尝试，如果下一轮的后手获胜，则当前轮的先手获胜。

3. 对数器计算连续有序数据的结果，

   **规律：每5个数为1个组，组内0和2位置的结果是“后手”，其它是先手。**

## 是否可以表示成若干连续正数和的数

定义一种数：可以表示成若干（数量>1）连续正数和的数

比如:

5 = 2+3，5就是这样的数

12 = 3+4+5，12就是这样的数

1不是这样的数，因为要求数量大于1个、连续正数和

2 = 1 + 1，2也不是，因为等号右边不是连续正数

给定一个参数N，返回是不是可以表示成若干连续正数和的数

**分析**

迭代尝试：

1. 尝试以1-N之间的每个数为连续正数和的起始数，然后往后加，直到等于N。

2. 对数器结果发现的规律：4的n次方的结果都为false。也就是一个数的二进制只包含一个1。

3. 两种实现方式：

   最右的1和n的值相同：n&(~n+1)=n;

   n-1与上n，结果为0：n&(n-1)=0;

## 打怪兽需要花的最小钱数

int[] d，d[i]：i号怪兽的能力

int[] p，p[i]：i号怪兽要求的钱

开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。

如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力，你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上。

返回通过所有的怪兽，需要花的最小钱数。

**分析**

暴力递归：**第一种递归尝试：**

1. 是从左到右的尝试模型

2. 到第index号怪兽，当前能力是P，

   当P大于等于当前怪兽的能力，就有两种选择：花钱雇佣或跳过。

   当P小于当前怪兽的能力，只能花钱雇佣。

3. 返回通过index后所有怪兽所花费的最少钱数。

**递归代码错误：**

从左到右的尝试，进入下一轮时，使用index+1，而不是index++，这样会改变当钱轮的下一次尝试的index值。

**重复计算分析**

power = { 5, 2, 2 }，money = { 3, 1, 10 };

f(0,0) -> f(1,5) ->  f(2,5)  & f(2,7)  -> f(3,5) & **f(3,7)  & f(3,7)**  & f(3,9)  

**动态规划**

power = { 2, 2, 3 }，money = { 5, 1, 3 };  

可变参数范围：怪兽号index【0-2】，当前英雄能力ability【0-7：不会比所有怪兽能力的累计和大】

严格表结构：d[index]\[ability] 表示通过了index-N关的怪兽，英雄能力大于等于ability时，最少花多少钱。

从下往上填：

最后一行都为0，因为index=3位置没有怪兽，所以花费最小都为0.

当怪兽位置index为2时，英雄的自身能力ability小于当前怪兽能力时，最小花费为当前怪兽的雇佣花费3，加上，通过index之后所有怪兽的最小花费0，等于3；英雄的自身能力ability大于等于当前怪兽能力时，最小花费为0。

当怪兽位置index为1时，英雄的自身能力ability小于当前怪兽能力时，最小花费为当前怪兽的雇佣花费1，加上，通过index之后所有怪兽的最小花费3，等于4；ability=1时，1+0=1；英雄的自身能力ability大于等于当前怪兽能力时，等于2，则最小花费为1；大于2则为0.

| index/ability | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0             | 6    | 5    | 1    | 0    | 0    | 0    | 0    | 0    |
| 1             | 4    | 1    | 1    | 0    | 0    | 0    | 0    | 0    |
| 2             | 3    | 3    | 3    | 0    | 0    | 0    | 0    | 0    |
| 3             | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

推出状态转移方程：dp\[i][j] = Math.min(dp\[i + 1][j], money[i] + dp\[i + 1][j + power[i]]);

**根据数据规模猜解法**

1. 若怪兽的能力值比较小：能力在100以内，怪兽数量index是100，则能力的累加和最大就是10000.，

   动态规划表的大小就是：10的6次方。可以**在10的8次方内填完（1秒内执行完）**

2. 若怪兽的能力值特别大：10^8 ~ 10^12 1亿左右。

   而动态规划表中的列ability的最大值是所有怪兽能力的累加和。表**不可能在10的8次方内填完。**

   不可以使用这样的动态规划。

采用**另一种递归尝试**：

1. 可变参数范围：怪兽位置index【0-2】，严格的花费waste能通过【0-9：怪兽的雇佣花费累计和】

2. dp[index]\[money] 表示通过0-index的怪兽，花费是waste时，英雄能达到的最大能力是多少。

   如果0-index，严格花waste元，能通过，结果是最大能达到的能力，

   否则**结果能力都是-1. ** （最大是因为要和-1比较，取有效值）。

4. 到达最后一个怪兽时，从左往右遍历，第一个不为-1的结果对应的花费，就是最终结果。

状态转移方程：

1. 不雇佣：

   dp[index-1]\[waste] != -1  结果为-1表示index之前的怪兽都无法通过，则决策失败。

   dp[index-1]\[waste] >= power[index]  则不需要雇佣。

2. 雇佣：当前index位置的怪兽， power是X，waste是Y。

   dp[index - 1]\[waste - Y] != -1  确保前一个怪兽，花费waste - Y元能通过，则当前index，正好花费waste元。

**总结**

以10的8次方为标准，分析入参：int[] d，d[i]：i号怪兽的能力，int[] p，p[i]：i号怪兽要求的钱，估计表规模，哪种能拿下。

1. 如果能力d的取值范围1-100，而p的取值范围大于10的6次方，使用第一种
2. 如果d的取值范围大于10的6次方，而p的取值范围1-100，使用第二种

## 非负数组子序列中累加和%m的最大值

给定一个非负数组arr，和一个正数m。

返回arr的所有子序列中累加和%m之后的最大值。

**分析**

arr长度不长，数值不大，但m比较大：

1. 如长度为1000，maxvalue=100，
2. 动态规划表的列为：arr数组累加和的范围。
3. dp[i]\[j]表示：不使用i位置的数字的结果 **或** 使用i位置的数字的结果。
4. 则dp表的列最大为10的5次方，行为10的3次方，可以在10的8次方内完成。

arr长度不长，数值比较大，但m不大：

1. 动态规划表的列为：arr数组累加和Modm后余数的范围。[0，m-1]

2. dp[i]\[j]表示：不使用i位置的数字的余数结果 **或** 使用i位置的数字的余数结果。

   arr[i] % m <= j 则 i-1位置的 j = j - arr[i] % m

   arr[i] % m > j 则 i-1位置的 j = j + m-arr[i] % m

arr的累加和很大，m也很大：

1. 如arr长度为30。每个位置要么要，要么不要，每步是二分。暴力展开是${2}^{30}=10^{9}$，超过了10^8。

2. 分治：30长度的数组分成左右各15个。每部分的代价变小，2^15=23768.

   计算每部分的余数结果，然后合并：遍历左部分，在右部分寻找配对，左右余数的和最接近m。

## 背包中有多少种零食放法

牛牛家里一共有n袋零食, 第i袋零食体积为v[i]，背包容量为w。

牛牛想知道在**总体积**不超过**背包容量**的情况下,

一共有多少种零食放法，体积为0也算一种放法

1 <= n <= 30, 1 <= w <= 2 * 10^9，v[i] (0 <= v[i] <= 10^9）

**分析**

1. 暴力尝试：从左到右的尝试。index位置选择 要 或 不要。

2. arr零食体积数组的总体积很大，但背包容量w不大：

   dp[i]\[j]表示：arr数组的 **i-n范围上** 的零食，体积不超过容量j，有多少种方法。

   dp[i]\[j] = dp[i+1]\[j] + dp[i+1]\[j - arr[i]] (要 或 不要)

3. arr零食体积数组的总体积不大，但背包容量w很大：

   dp[i]\[j]表示：arr数组的 **0-i范围上** 的零食，体积正好凑够容量j，有多少种方法。

   dp[i]\[j] = dp[i-1]\[j] + dp[i-1]\[j - arr[i]]   (不要 或 要)

4. 分治

