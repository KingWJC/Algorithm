# 对数器找规律

暴力递归和对数器是通用技巧

1. 若题目中，输入参数简单，只有一个实际参数

2. 要求的输出参数简单，且只有一个。

3. 用暴力尝试，执行一段连续的输入值，打印结果，寻找抽象规律，并优化code。

   **算法有两大类：明确知道怎么算，和 知道怎么尝试（递归）**

# 根据数据规模猜解法

ACM的第一个需要掌握的技巧

1. C/C++,1秒处理的指令条数为10的8次方
2. Java等语言，1-4秒处理的指令条数为10的8次方。
3. 根据数据规模，选择合适的时间复杂度的算法。

# 分治的应用场景

1. 数据量整体做尝试的可能性太多，跑不完
2. 数据分成多个块（常见是两块）之后，各个块的可能性不多。
3. 合并多个块的信息的整合过程并不复杂。

# 题目

## 至少使用多少袋子装苹果

小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量。

1）能装下6个苹果的袋子

2）能装下8个苹果的袋子

小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，且使用的每个袋子必须装满。

给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1

**分析**

先尽量用能装下8个苹果的袋子装，需要几个袋子？

剩下的用能装下6个苹果的袋子装，需要几个袋子？

若装不满，则少用1个能装下8个苹果的袋子，再去尝试用能装下6个苹果的袋子装。

暴力尝试，并用1-100连续的数，测试其结果，然后分析规律。

1. 奇数一定不符合，返回-1

2. 从18开始，每8个数为1组。

   18-25 8个数 偶数返回3，奇数返回-1

   26-33 8个数 偶数返回4，奇数返回-1

3. [18,....) 之后的结果：(apple-18)/8 + 3

## 牛羊吃N份青草谁会赢

给定一个正整数N，表示有N份青草统一堆放在仓库里

有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草

不管是牛还是羊，每一轮能吃的草量必须是：

1，4，16，64…(4的某次方)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             

谁最先把草吃完，谁获胜

假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定

根据唯一的参数N，返回谁会赢

**分析**

递归尝试：

1. 每一轮选择，能吃的草量，在【1】到【4^n<N】范围上进行尝试。

2. 每次尝试，如果下一轮的后手获胜，则当前轮的先手获胜。

3. 对数器计算连续有序数据的结果，

   **规律：每5个数为1个组，组内0和2位置的结果是“后手”，其它是先手。**

## 是否可以表示成若干连续正数和的数

定义一种数：可以表示成若干（数量>1）连续正数和的数

比如:

5 = 2+3，5就是这样的数

12 = 3+4+5，12就是这样的数

1不是这样的数，因为要求数量大于1个、连续正数和

2 = 1 + 1，2也不是，因为等号右边不是连续正数

给定一个参数N，返回是不是可以表示成若干连续正数和的数

**分析**

迭代尝试：

1. 尝试以1-N之间的每个数为连续正数和的起始数，然后往后加，直到等于N。

2. 对数器结果发现的规律：4的n次方的结果都为false。也就是一个数的二进制只包含一个1。

3. 两种实现方式：

   最右的1和n的值相同：n&(~n+1)=n;

   n-1与上n，结果为0：n&(n-1)=0;

## 打怪兽需要花的最小钱数

int[] d，d[i]：i号怪兽的能力

int[] p，p[i]：i号怪兽要求的钱

开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。

如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力，你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上。

返回通过所有的怪兽，需要花的最小钱数。

**分析**

暴力递归：

1. 是从左到右的尝试模型

2. 到第index号怪兽，当前能力是P，

   当P大于等于当前怪兽的能力，就有两种选择：花钱雇佣或跳过。

   当P小于当前怪兽的能力，只能花钱雇佣。

3. 返回通过index后所有怪兽所花费的最少钱数。

**递归代码错误：**

从左到右的尝试，进入下一轮时，使用index+1，而不是index++，这样会改变当钱轮的下一次尝试的index值。

**重复计算分析**

power = { 5, 2, 2 }，money = { 3, 1, 10 };

f(0,0) -> f(1,5) ->  f(2,5)  & f(2,7)  -> f(3,5) & **f(3,7)  & f(3,7)**  & f(3,9)  

**动态规划**

power = { 2, 2, 3 }，money = { 5, 1, 3 };  

可变参数范围：index【0-2】，ability【0-7：不会比所有怪兽能力的累计和大】

严格表结构：d[index]\[ability] 表示通过了0-index关的怪兽，英雄能力大于等于ability时，最少花多少钱。

当怪兽位置index为0时，英雄的自身能力ability=0时，花费为0；等于1-2时，都需要花费5；ability不可能大于index=0位置的怪兽能力2，所以3-7的花费为-1。

当怪兽位置index为1时，英雄的自身能力ability不可能小于index-1位置的怪兽能力，所以0，1的花费为-1；ability不可能大于index=1位置之前的怪兽能力总和4，所以花费为-1。

| index/ability | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0             | 0    | 5    | 5    | -1   | -1   | -1   | -1   | -1   |
| 1             | -1   | -1   | 5    | 6    | 6    | -1   | -1   | -1   |
| 2             | -1   | -1   | -1   | -1   | 6    | 9    | 9    | 9    |

推出状态转移方程：

**根据数据规模猜解法**

1. 若怪兽的能力值比较小：能力在100以内，怪兽数量index是100，则能力的累加和最大就是10000.，

   动态规划表的大小就是：10的6次方。可以**在10的8次方内填完（1秒内执行完）**

2. 若怪兽的能力值特别大：10^8 ~ 10^12 1亿左右。

   而动态规划表中的列ability的最大值是所有怪兽能力的累加和。表**不可能在10的8次方内填完。**

   不可以使用这样的动态规划。



## 非负数组子序列中累加和%m的最大值

给定一个非负数组arr，和一个正数m。

返回arr的所有子序列中累加和%m之后的最大值。



## 背包中有多少种零食放法

牛牛家里一共有n袋零食, 第i袋零食体积为v[i]，背包容量为w。

牛牛想知道在总体积不超过背包容量的情况下,

一共有多少种零食放法，体积为0也算一种放法

1 <= n <= 30, 1 <= w <= 2 * 10^9，v[i] (0 <= v[i] <= 10^9）