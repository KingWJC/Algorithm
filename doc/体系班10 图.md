# 定义

图是一种复杂的非线性结构。维护一对多的关系

- 在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素（除第一个和最后一个外）只有一个直接前趋和一个直接后继。
- 在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层中的一个元素（父节点）和下一层的多个元素（孩子节点）相关。
- 在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。

图G由由两个集合V（顶点Vertex）和E（边Edge）组成，定义为G=（V，E），每个边是一个元组 (v，w) ，其中 w,v ∈ V 。

- **顶点**（也称为“节点”）是图的基本部分。它可以有一个名称，我们将称为“键”。一个顶点也可能有额外的信息。我们将这个附加信息称为“有效载荷”。
- **边**（也称为“弧”）是图的另一个基本部分。边连接两个顶点，以表明它们之间存在关系。边可以是单向的或双向的。如果图中的边都是单向的，我们称该图是有向图 。
- **权重** 边可以被加权以示出从一个顶点到另一个顶点的成本。例如，在将一个城市连接到另一个城市的道路的图表中，边上的权重可以表示两个城市之间的距离。

加权有向图的示例：边元组中第三位来表示权重

![img](images/1286166-20181106191123305-1941542354.png)

将该图表示为六个顶点的集合：V = { V0，V1，V2，V3，V4，V5 }，和 9 条边的集合 E = {(v0，v1，5)，(v1，v2，4)，(v2，v3，9)，(v3，v4，7)，(v4，v0，1)，(v0，v5，2)，(v5，v4，8)，(v3，v5，3)，(v5，v2，1)}

- **路径** ：图中的路径是由边连接的顶点序列。形式上，我们将定义一个路径为 w1，w2，...，wn ，使得 (wi，wi + 1) ∈ E , 当 1≤i≤ n-1 。

  **未加权路径长度是路径中的边的数目，具体是 n-1**。**加权路径长度是路径中所有边的权重的总和**。

  例如在上图中，从 V3 到 V1 的路径是顶点序列 (V3，V4，V0，V1) 。边是 {（v3，v4,7），（v4，v0,1），（v0，v1,5）} } 。

- **循环（回路）** ：有向图中的循环是在同一顶点开始和结束的路径。例如，在 上图中，路径 （V5，V2，V3，V5） 是一个循环。没有循环的图形称为非循环图形。没有循环的有向图称为有向无环图或DAG

# 概念和术语

## 无向图和有向图

**无向图**

对于一个图，若每条边都是没有方向的，则称该图为无向图。图示如下：

![img](images/23224319-542b3e34bb934877871ec042397c8b42-20220113045619862.jpg)

无向图的顶点集和边集分别表示为：

V(G)={V1，V2，V3，V4，V5}

E(G)={(V1，V2)，(V1，V4)，(V2，V3)，(V2，V5)，(V3，V4)，(V3，V5)，(V4，V5)}

**有向图**

对于一个图G，若每条边都是有方向的，则称该图为有向图。图示如下。

![img](images/23224322-bb9cc704825d448a973befed8cc93538.jpg)

有向图的顶点集和边集分别表示为：

V(G)={V1，V2，V3}

E(G)={<V1，V2>，<V2，V3>，<V3，V1>，<V1，V3>}

**有向图和无向图的区别：**

1. 无向图中，(Vi，Vj)和(Vj，Vi)表示的是同一条边。
2. 有向图中，<Vi，Vj>和<Vj，Vi>是两条不同的有向边。
3. 边的表示：**无向图是用小括号，有向图是用尖括号，有向边又称为弧**。
4. 将具有n(n-1)/2条边的无向图称为**无向完全图**。同理，将具有n(n-1)条边的有向图称为**有向完全图**。
5. 虽然存在有向图和无向图的概念，但实际上都可以用有向图来表达

## 顶点的度

对于无向图，顶点的度表示以该顶点作为一个端点的边的数目。比如，图(a)无向图中顶点V3的度D(V3)=3

对于有向图，顶点的度分为**入度和出度**。入度表示以该顶点为终点的入边数目，出度是以该顶点为起点的出边数目，该顶点的度等于其入度和出度之和。比如，顶点V1的入度ID(V1)=1，出度OD(V1)=2，所以D(V1)=ID(V1)+OD(V1)=1+2=3

记住，不管是无向图还是有向图，顶点数n，边数e和顶点的度数有如下关系：
$$
e=\frac{1}{2}\displaystyle\sum\limits_{i=1}^n D(Vi)
$$
有向图(b)，可用公式可以得到图G的边数e=(D(V1)+D(V2)+D(V3))/2=(3+2+3)/2=4

## 连通图

顶点连通：两个顶点之间存在一条连接双方的路径。

连通图：任意一个顶点都存在一条路径到达另一个任意顶点。

# 表示图

## 邻接矩阵法

1. 使用二维矩阵。（没有直接边，设为空或正无穷）。
2. 在该矩阵实现中，每个行和列表示图中的顶点。
3. 存储在行 v 和列 w 的交叉点处的单元中的值表示是否存在从顶点 v 到顶点 w 的边。
4. 当两个顶点通过边连接时，我们说它们是相邻的。 

下图展示了 上图的邻接矩阵。单元格中的值也可以表示从顶点 v 到顶点 w 的边的权重。

![这里写图片描述](images/SouthEast.png)

优点是简单，对于小图，很容易看到哪些节点连接到其他节点。但矩阵不是一种非常有效的方式来存储稀疏数据。

## 邻接表法

1. 将每个顶点的所有相连顶点都保存在该顶点对应的元素所指向的一张链表中。
2. 这种结构可以满足典型应用，所以后面实现的各种图数据结构，都是基于邻接表。

![这里写图片描述](images/SouthEast-20220113045916783.png)

优点：

1. 在于总是使用与V+E成正比空间，类似与HashMap<T,List<T>>
2. 可以紧凑地表示稀疏图，
3. 很容易找到直接连接到特定顶点的所有链接。

## 其它方式

其它表达方式的数据结构如下：

1. 用二维数组表示：[ [3，0，7]，[5，1，2]，[6，2，7] ]， 

   每个数组代表一个边，如第一个元素，权重是3，边是从0到7.

2. 用一个数组表示：[3，1，1，1]，用索引表示每一个节点，用值来表示与它相连的节点，但一个节点只能向外出一条指针。

## 图的难点

图的算法都不算难，只不过coding的代价比较高，因为图的表示形式多样化。

1）先用自己最熟练的方式，实现图结构的表达

2）在自己熟悉的结构上，实现所有常用的图算法作为模板

3）使用适配器，把面试题提供的图结构转化为自己熟悉的图结构，再调用模板或改写即可

### 抽象数据类型

- Vertex：值，入度（边指向它），出度（指向其它节点），邻居节点（从我出发找到的邻居节点），边（从我出发找到的边）
- Edge：权重，起点，终点
- Graph 创建一个新的空图。点集，边集。（用户会用整型来指定点，用点来封装整型数据）

### 转换适配器

从二维数组转换，每个数组代表一个边。

# 查询方式

## 广(宽)度优先遍历

breadth-first-search BFS，广度优先搜索类似于二叉树的层序遍历，它的基本思想就是：首先访问起始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点w1，w2，…，wi，然后再依次访问w1，w2，…，wi的所有未被访问过的邻接顶点

![img](https://upload-images.jianshu.io/upload_images/18019269-1b9f2c58cfa66387.png?imageMogr2/auto-orient/strip|imageView2/2/w/455/format/webp)

1. 利用队列实现 , 来保存所有已经被标记过但是其邻接表还未被检查过的顶点。
2. 从源节点开始依次按照宽度进队列，然后弹出  
3. 每弹出一个点，把该节点所有没有进过队列的邻接点放入队列  
4. 直到队列变空  

![这里写图片描述](https://img-blog.csdn.net/20171217190411001?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDcxMDQ1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**BFS可以解决的问题：**

1. 查找一个顶点的最短路径

## 深度优先遍历

是从起始顶点开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底。利用可以下压的栈（递归支持）

![img](https://upload-images.jianshu.io/upload_images/18019269-ae304b3734a08775.png?imageMogr2/auto-orient/strip|imageView2/2/w/312/format/webp)

使用深度有限搜索的轨迹，寻找所有和顶点0连通的顶点。

迭代非递归实现：

1. 利用栈实现 ，栈中放着的总是一条路径。
2. 从源节点开始把节点按照深度放入栈，然后弹出 
3. 每弹出一个点，把该节点和它的下一个没有进过栈的邻接点放入栈 
4. 直到栈变空   

邻接表中节点插入顺序影响了升读选取节点的顺序，但不影响结果。

![这里写图片描述](https://img-blog.csdn.net/20171215213337237?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDcxMDQ1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**DFS可以解决的问题**

1. 单点的连通性（两个顶点是否连通）和单点路径

2. 图中的连通分量

   一次dfs可以找出含有起点的某个连通图，如果对所有的顶点进行dfs就可以找出全部连通图并且由于遍历过的点都标记了，所以不会重复以其为起点进行dfs

3. 检测环

4. 双色问题

# 算法

## 拓扑排序

在图论中，拓扑排序（Topological Sorting）是一个**有向无环图**（DAG, Directed Acyclic Graph）的所有顶点的线性序列。

也可以说，拓扑排序并不是一个纯粹的排序算法，它只是针对**有向无环图**，找到一个可以执行的线性顺序。

- 如果这个图不是 DAG，那么它是没有拓扑序的；
- 如果是 DAG，那么它至少有一个拓扑序。（**有一个或多个拓扑排序序列。拓扑排序不唯一**）
- 反之，如果它存在一个拓扑序，那么这个图必定是 DGA。 所以这是一个充分必要条件。

### 拓扑序

示例：课程表

![img](https://pics4.baidu.com/feed/908fa0ec08fa513df677d0a17f7dc3fdb3fbd983.jpeg?token=b7276fa3372e86a8f54cb79ba906f9c8)

这里有 9 门课程，有些课程是有先修课程的要求的，就是你要先学了「最右侧这一栏要求的这个课」才能再去选「高阶」的课程。

那么这个例子中拓扑排序的意思就是：就是求解一种可行的顺序，能够让我把所有课都学了。

**描述：**

首先我们可以用**图**来描述它，图的两个要素是**顶点和边**，那么在这里：

顶点：每门课 边：起点的课程是终点的课程的先修课

画出来长这个样：

![img](https://pics2.baidu.com/feed/cb8065380cd791230251596eea24cf84b2b7800a.jpeg?token=f5bb3f0e3f5739426b8c5f35a7606273)

1. 这种图叫**AOV**(Activity On Vertex) 网络，在这种图里：

   顶点：表示活动； 边：表示活动间的先后关系

2. **所以一个 AOV 网应该是一个 DAG，即有向无环图，否则某些活动会无法进行。**

3. **那么所有活动可以排成一个可行线性序列，这个序列就是拓扑序列。**

4. 那么这个序列的**实际意义**是：

   **按照这个顺序，在每个项目开始时，能够保证它的前驱活动都已完成，从而使整个工程顺利进行。**

回到我们这个例子中：

1. 我们一眼可以看出来要先学 C1, C2，因为这两门课没有任何要求嘛，大一的时候就学呗；
2. 大二就可以学第二行的 C3, C5, C8 ，因为这三门课的先修课程就是 C1, C2，我们都学完了；
3. 大三可以学第三行的 C4, C9；
4. 最后一年选剩下的 C6, C7。

这样，我们就把所有课程学完了，也就得到了这个图的一个**拓扑排序**。

注意，有时候拓扑序并不是唯一的，比如在这个例子中，先学 C1 再学 C2，和先 C2 后 C1 都行，都是这个图的正确的拓扑序，但这是两个顺序了。

所以面试的时候要问下面试官，是要求解任意解，还是列出所有解。

我们总结一下，

**在这个图里的边表示的是一种依赖关系，如果要修下一门课，就要先把前一门课修了。**

### 实现步骤：

1. **预处理得到每个点的入度**，可以用一个 HashMap 或数组来存放这个信息

2. 从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。**因为只有当它的入度为 0的时候，我们才能执行它。**

   把没有前驱（即入度为0）的顶点，放入一个**待执行的容器**里，这样之后我们一个个的从这个容器里取顶点就好了。

3. 从图中删除该顶点和所有以它为起点的有向边，该顶点所指向的顶点 的 入度-1

4. 重复 2 和 3 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。



![img](https:////upload-images.jianshu.io/upload_images/18019269-84ec841b4441c905.png?imageMogr2/auto-orient/strip|imageView2/2/w/544/format/webp)

于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。

实现上的细节：

1. 当我们 check 是否有新的顶点的 入度 == 0 时，没必要过一遍整个 map 或者数组，只需要 check 刚刚改动过的就好了。

2. 另一个是如果题目没有给这个图是 DAG 的条件的话，那么有可能是不存在可行解的。

   比较一下最后结果中的顶点的个数和图中所有顶点的个数是否相等，如果不相等，说明就不存在有效解。所以这个算法也可以用来**判断一个图是不是有向无环图。有环证明有相互依赖，入度就不可能为0.**

**时间复杂度**

**注意：**对于图的时间复杂度分析一定是两个参数，因为图的顶点数和边的数量没有固定的关系，然而面试的时候很多同学张口就是 O(n)...

对于有 v 个顶点和 e 条边的图来说，

第一步，预处理得到 map 或者 array，需要过一遍所有的边才行，所以是 O(e)；

第二步，把 入度 == 0 的点入队出队的操作是 O(v)，如果是一个 DAG，那所有的点都需要入队出队一次；

第三步，每次执行一个顶点的时候，要把它指向的那条边消除了，这个总共执行 e 次；

**总：O(v + e)**

**空间复杂度**

用了一个数组来存所有点的 indegree，之后的 queue 也是最多把所有的点放进去，所以是 O(v).

### 应用

拓扑排序通常用来“排序”具有依赖关系的任务。它与深度优先搜索BFS类似。不同的是，拓扑排序算法不会立即输出已访问的顶点，而是访问当前顶点邻接表中的所有相邻顶点，直到这个列表穷尽时，才将当前顶点压入栈中。

1. 事件安排、工作流，任意两个任务要么具有确定的先后关系，要么是没有关系，绝对不存在互相矛盾的关系（即环路）
2. 编译顺序，如编译时不能每个项目之间不能有循环依赖，编译顺序就是拓扑序。

### 题目

拓扑排序 https://www.lintcode.com/problem/topological-sorting/

两种方法：点数越大，拓扑序越小；顶点深度越深，拓扑序越小。

## 最小生成树

### Kruskal

1）总是从权值最小的边开始考虑，依次考察权值依次变大的边  
2）当前的边要么进入最小生成树的集合，要么丢弃  
3）如果当前的边进入最小生成树的集合中不会形成环，就要当前边  
4）如果当前的边进入最小生成树的集合中会形成环，就不要当前边  
5）考察完所有边之后，最小生成树的集合也得到了    

### Prim

1）可以从任意节点出发来寻找最小生成树  
2）某个点加入到被选取的点中后，解锁这个点出发的所有新的边  
3）在所有解锁的边中选最小的边，然后看看这个边会不会形成环  
4）如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复3）  
5）如果不会，要当前边，将该边的指向点加入到被选取的点中，重复2）  
6）当所有点都被选取，最小生成树就得到了  

### Dijkstra算法

1）Dijkstra算法必须指定一个源点   
2）生成一个源点到各个点的最小距离表，一开始只有一条记录，即原点到自己的最小距离为0，源点到其他所有点的最小距离都为正无穷大  
3）从距离表中拿出没拿过记录里的最小记录，通过这个点发出的边，更新源点到各个点的最小距离表，不断重复这一步  
4）源点到所有的点记录如果都被拿过一遍，过程停止，最小距离表得到了  

利用加强堆

某个节点最短距离改变时做动态调整

