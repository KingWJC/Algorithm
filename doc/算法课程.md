算法课程：

老：基础16节，基础低，中。    进阶78节，基础高，经典高频的题（17-48）。

新：体系学习，47节(基础低，中，高）练习题和升级知识点。  大厂刷题(进阶班的题+新题)

学习方式：

新手班-》体系学习班47节-》进阶班（49-78）-》进阶17-48=》大厂刷题班（实时新题）。

笔记网站：https://shimo.im/docs/68cd6h3TwygPwx8W/read

# 新手班

## 01 位运算,算法,简单排序

7种位运算 bitwise：

1. & 与:  遇0则0

2. | 或：遇1则1

3. ! 非：1-0，0-1

4. ^ 异或：相同为0，相异为1.（不进位加法）。

5. \>>右移：补符号位。（当前符号位为1补1，为0补0)，首位。

6. <<左移：补0. 末尾

7. \>>>无符号右移：补0. 首位。

算法

1）有具体的问题

2）有设计解决这个问题的具体流程

3）有评价处理流程的可量化指标

算法的分类

  1   明确知道怎么算的流程   :诗人拜仑的女儿. 打孔程序.

  2   明确知道怎么尝试的流程  :  图灵, 破解密码, 找出一个原型, 把不知怎么算, 但知道怎么试的问题, 试出来 . 

示例题目

- 题目一: [[阶乘计算]]  
- 题目二: [[选择排序]]  
- 题目三: [[冒泡排序]]  
- 题目四: [[插入排序]]  

## 02 前缀和数组、对数器和随机行为

数据结构

1）数据结构是存储、组织数据的方式.  任何数据结构都是 连续结构 跟 跳转结构两个 拼出来的

2）精心选择的数据结构可以带来更高的运行或者存储效率

3）数据结构是很多算法得以进行的载体

最基本的数据结构

1）数组: 便于寻址，不便于增删数据

2）链表: 便于增删数据，不便于寻址

对数器的使用

- 选择、冒泡、插入排序的对数器验证

示例题目

-  假设有一个数组arr，用户总是频繁的查询arr中某一段的累加和, 如何组织数据，能让这种查询变得便利和快捷？ **预处理结构(前缀和数组).**
- 调整数出现的概率从x调整为x^2.   **Math.random() 返回[0,1)**
- 概率生成数字问题, 使用等概率函数f(x), (1-5的随机),  返回1-7等概率.   **0,1发生器**.
- a~b等概率随机到c~d的等概率随机生成数字.
- 01不等概率随机到01等概率随机

## 03 二分、复杂度、动态数组、哈希表和有序表

二分法

1. [[有序数组中找到num]]   
2. [[有序数组中找到＞=num最左的位置]]   
3. [[有序数组中找到＜=num最右的位置]]   
4. [[局部最小值问题]] , 无序且相邻不等的数组, 找一个局部最小值(比前后都小). 
   1. 若arr[0]>arr[1] 下降 且 arr[n-2]< arr[n-1] 上升, 则mid肯定有局部最小值
   2. 二分不一定有序.

**时间复杂度**

1. 常数(固定)时间的操作: 1+1, 100w+100w, 数组寻址 arr[3], arr[100w]. 

2. 复杂(变化)时间的操作: 操作时间与数据量有关.

3. 冒泡排序的时间复杂度: 

   1. 等差数列求和: Sn=n\*a1+n\*(n-1)*d/2

   2. ![img](images/60ecc12727239746b13f36598828f2e4.svg)

   3. 时间复杂度: O(n^2), 只关心最高阶是多少. 省略低阶项和系数.
      $$
      Sn = a1*n+\frac{n^2-n}{2}
      	 = \frac{n^2}{2} - (\frac{1}{2}-a1)*n
      	 = a*n^2 + b*n + c
      	 \approx n^2
      $$

   4. 当数据量n很大, 系数项a跟低阶项b*n+c根本不重要, 决定算法运行时间的就是最高阶项

4. 二分法的时间复杂度: O(logN).
   1. 一般来讲底数是被省略了, $O(logN)$默认就是以2为底的, 有时候$O(log_7N)$也写成$O(logN)$   
   2. 因为你底数不管是多少, 它出来的值都很小, long类型, 最大2^64, 这么大的数, 二分的话, 64次就处理完了 ,所以往往就忽略这个底,    
   3. 如果这个底等于2或者比2大, 它出来的结果都会很小, 所以默认就写成 $O(logN)$了 
5. 常数操作的时间复杂度: O(1)

动态数组, Java中**ArrayList 扩容**的代价:

1. 从arr[1]到arr[2], 扩容的操作多了两步: 生成新的扩容数组, 将arr[1]拷贝到arr[2]中.
1. 从arr[1]到arr[N], 扩容的代价为1+2+4+8......+N 为等比数列. 时间复杂度是O(N)
1. 但每一步的扩容 时间复杂度是O(1), 
1. 所以动态数组虽然有扩容, 相比固定数组只是常数时间的慢, 但对整体性能的时间复杂度上没有影响.

Java中的哈希表

不管数据量多大, 增删改查操作都是O(1), 时间是常数时间,但比加法, 数组寻址的常数操作都慢.

1. 按值传递: 基础类型
2. 按引用传递: 非基础类型,自定义.

Java中的有序表TreeMap: 操作都是O(logN)

## 04 单链表跟双链表

单链表：值，一条next指针

双链表：值，一条last指针，一条next指针

经典题目:

1. 单链表和双链表如何反转

   1. 给定一个单链表的头head，完成链表的逆序调整
   2. 给定一个双链表的头head，完成链表的逆序调整
   3. 逆序调整后必须返回新的头节点, 并重置头节点, 否则JVM会进行垃圾回收.

2. 用双链表实现双端队列

3. K个节点的组内逆序调整

   https://leetcode-cn.com/problems/reverse-nodes-in-k-group/   

4. 两个链表相加

   https://leetcode-cn.com/problems/add-two-numbers/   

   >先遍历两个链表, 把较长的重新定位一下  
   >
   >1) L 有 S有
   >2) S无 L有
   >3) S无 L无

5. 两个有序链表的合并

   https://leetcode-cn.com/problems/merge-two-sorted-lists     

   >重新定位一下, cur1指向小头, cur2指向大头

05 
