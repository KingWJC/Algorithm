算法课程：

老：基础16节，基础低，中。    进阶78节，基础高，经典高频的题（17-48）。

新：体系学习，47节(基础低，中，高）练习题和升级知识点。  大厂刷题(进阶班的题+新题)

学习方式：

新手班-》体系学习班47节-》进阶班（49-78）-》进阶17-48=》大厂刷题班（实时新题）。

笔记网站：https://shimo.im/docs/68cd6h3TwygPwx8W/read

# 新手班

## 01 位运算,算法,简单排序

7种位运算 bitwise：

1. & 与:  遇0则0

2. | 或：遇1则1

3. ! 非：1-0，0-1

4. ^ 异或：相同为0，相异为1.（不进位加法）。

5. \>>右移：补符号位。（当前符号位为1补1，为0补0)，首位。

6. <<左移：补0. 末尾

7. \>>>无符号右移：补0. 首位。

算法

1）有具体的问题

2）有设计解决这个问题的具体流程

3）有评价处理流程的可量化指标

算法的分类

  1   明确知道怎么算的流程   :诗人拜仑的女儿. 打孔程序.

  2   明确知道怎么尝试的流程  :  图灵, 破解密码, 找出一个原型, 把不知怎么算, 但知道怎么试的问题, 试出来 . 

示例题目

- 题目一: [[阶乘计算]]  
- 题目二: [[选择排序]]  
- 题目三: [[冒泡排序]]  
- 题目四: [[插入排序]]  

## 02 前缀和数组、对数器和随机行为

数据结构

1）数据结构是存储、组织数据的方式.  任何数据结构都是 连续结构 跟 跳转结构两个 拼出来的

2）精心选择的数据结构可以带来更高的运行或者存储效率

3）数据结构是很多算法得以进行的载体

最基本的数据结构

1）数组: 便于寻址，不便于增删数据

2）链表: 便于增删数据，不便于寻址

对数器的使用

- 选择、冒泡、插入排序的对数器验证

示例题目

-  假设有一个数组arr，用户总是频繁的查询arr中某一段的累加和, 如何组织数据，能让这种查询变得便利和快捷？ **预处理结构(前缀和数组).**
- 调整数出现的概率从x调整为x^2.   **Math.random() 返回[0,1)**
- 概率生成数字问题, 使用等概率函数f(x), (1-5的随机),  返回1-7等概率.   **0,1发生器**.
- a~b等概率随机到c~d的等概率随机生成数字.
- 01不等概率随机到01等概率随机

## 03 二分、复杂度、动态数组、哈希表和有序表

二分法

1. [[有序数组中找到num]]   
2. [[有序数组中找到＞=num最左的位置]]   
3. [[有序数组中找到＜=num最右的位置]]   
4. [[局部最小值问题]] , 无序且相邻不等的数组, 找一个局部最小值(比前后都小). 
   1. 若arr[0]>arr[1] 下降 且 arr[n-2]< arr[n-1] 上升, 则mid肯定有局部最小值
   2. 二分不一定有序.

**时间复杂度**

1. 常数(固定)时间的操作: 1+1, 100w+100w, 数组寻址 arr[3], arr[100w]. 

2. 复杂(变化)时间的操作: 操作时间与数据量有关.

3. 冒泡排序的时间复杂度: 

   1. 等差数列求和: Sn=n\*a1+n\*(n-1)*d/2

   2. ![img](images/60ecc12727239746b13f36598828f2e4.svg)

   3. 时间复杂度: O(n^2), 只关心最高阶是多少. 省略低阶项和系数.
      $$
      Sn = a1*n+\frac{n^2-n}{2}
      	 = \frac{n^2}{2} - (\frac{1}{2}-a1)*n
      	 = a*n^2 + b*n + c
      	 \approx n^2
      $$

   4. 当数据量n很大, 系数项a跟低阶项b*n+c根本不重要, 决定算法运行时间的就是最高阶项

4. 二分法的时间复杂度: O(logN).
   1. 一般来讲底数是被省略了, $O(logN)$默认就是以2为底的, 有时候$O(log_7N)$也写成$O(logN)$   
   2. 因为你底数不管是多少, 它出来的值都很小, long类型, 最大2^64, 这么大的数, 二分的话, 64次就处理完了 ,所以往往就忽略这个底,    
   3. 如果这个底等于2或者比2大, 它出来的结果都会很小, 所以默认就写成 $O(logN)$了 
5. 常数操作的时间复杂度: O(1)

动态数组, Java中**ArrayList 扩容**的代价:

1. 从arr[1]到arr[2], 扩容的操作多了两步: 生成新的扩容数组, 将arr[1]拷贝到arr[2]中.
1. 从arr[1]到arr[N], 扩容的代价为1+2+4+8......+N 为等比数列. 时间复杂度是O(N)
1. 但每一步的扩容 时间复杂度是O(1), 
1. 所以动态数组虽然有扩容, 相比固定数组只是常数时间的慢, 但对整体性能的时间复杂度上没有影响.

Java中的哈希表

不管数据量多大, 增删改查操作都是O(1), 时间是常数时间,但比加法, 数组寻址的常数操作都慢.

1. 按值传递: 基础类型
2. 按引用传递: 非基础类型,自定义.

Java中的有序表TreeMap: 操作都是O(logN)

## 04 单链表跟双链表

单链表：值，一条next**指针**

双链表：值，一条last指针，一条next指针

经典题目:

1. 单链表和双链表如何反转

   1. 给定一个单链表的头head，完成链表的逆序调整
   2. 给定一个双链表的头head，完成链表的逆序调整
   3. 逆序调整后必须返回新的头节点, 并重置头节点, 否则JVM会进行垃圾回收.

2. 用双链表实现双端队列

   1. 单链表在删除时, 无法找到上一个元素.

3. K个节点的组内逆序调整

   https://leetcode-cn.com/problems/reverse-nodes-in-k-group/   

4. 两个链表相加

   https://leetcode-cn.com/problems/add-two-numbers/   

   >先遍历两个链表, 把较长的重新定位一下  
   >
   >1) L 有 S有
   >2) S无 L有
   >3) S无 L无 进阶.

5. 两个有序链表的合并

   https://leetcode-cn.com/problems/merge-two-sorted-lists     

   >重新定位一下, cur1指向小头, cur2指向大头

## 05 位图跟位运算

位图: bitmap --> 用bit(位) 实现 map 的功能   

1，位图的功能

2，位图的好处

3，位图的实现

用位运算实现+ - * /加减乘除

1，加法:  {^ 异或, 不进位加法}   +   {&(都为1才进位)后, <<1得进位}
2，减法: 相反数, 求补码. 取反加1.
3，乘法: 若b的最后一位是1, 则结果加1个a, 循环b的每一位是否为1.
4，除法: a/b=c => a=b*2^1+b\*2^2+b\*2^n,获取是1的位, 拼成的二进制数就是c, 

## 06 比较器、优先级队列和二叉树

比较器: 实现Comparator.compare(a,b)和Comparable.compareTo(b)两种方式.

优先级队列（堆）、有序表

Java中的Stack结构

二叉树:

改动态规划全是递归,

题目

1. 合并多个有序链表 https://leetcode.com/problems/merge-k-sorted-lists
2. 判断两颗树是否结构相同 https://leetcode-cn.com/problems/same-tree
3. 判断一棵树是否是镜面树  https://leetcode-cn.com/problems/symmetric-tree
4. 返回一棵树的最大深度 https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/
5. 用先序数组和中序数组重建一棵树 https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
6. 二叉树按层遍历并收集节点 https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/
7. 判断是否是平衡搜索二叉树 https://leetcode-cn.com/problems/balanced-binary-tree/
8. 能否组成路径和 https://leetcode-cn.com/problems/path-sum/
9. 收集达标路径和 https://leetcode-cn.com/problems/path-sum-ii/

## 07 归并排序和快排


---

## [[归并排序]]

1）整体是递归，左边排好序+右边排好序+merge让整体有序  
2）让其整体有序的过程里用了排外序方法  
3）利用master公式来求解时间复杂度  
4）当然可以用非递归实现  
[[归并排序代码]]  

## [[快速排序]]

### 实现一个小函数

对于数组最后一个值x, <=x的整体放在左边, >x的整体放在右边   
不要用辅助数组, 时间复杂度O(N) 完成这个调整
![[Pasted image 20210204190614.png]]

```text
设计一个区域, 叫<=区, 
拿数组最右侧的数P做划分, 依从从0位置的数往后遍历:  
1) 如果当前数<=P, 当前数和<=区下一个数做交换, 然后<=区右扩, 当前数跳下一个
2) 如果当前数>P, 当前数直接跳下一个
```

```java
public static void splitNum(int[] arr) {
    int lessEqualR = -1;
    int index = 0;
    int mostR = arr.length - 1;
    while (index < arr.length) {
        if(arr[index] <= arr[mostR]) {
            swap(arr, index++, ++lessEqualR);
        } else {
            index++;
        }
    }
}
```

### 加强版   

一个数组中, 拿数组最右侧的数P做划分, 做到:    
Px的整体放在左边, =P的整体放在中间, >P的整体放在右边   
![[Pasted image 20210204190655.png]]

```text
小于区放在数组左边, 大于区在数组右边, 当前数从0开始, 有3种可能:
1) 当前数<P, 当前数跟小于区的下一个数交换, 小于区向右扩, 当前数跳到下一个
2) 当前数>P, 当前数跟大于区的前一个数交换, 大于区向左扩, 当前数不动
3) 当前数=P, 当前数直接跳下一个

当前数跟大于区域的边界撞上的时候不用遍历了
最后一个数 跟 大于区域的第一个数交换就做到了
<P的整体放在左边, =P的整体放在中间, >P的整体放在右边
```

```java
public static void splitNum2(int[] arr, int L, int R) {
    int N = arr.length;
    int lessR = -1;
    int moreL = N - 1;
    int index = 0;
    // arr[N-1]
    while (index < moreL) {
        if (arr[index] < arr[N - 1]) {
            swap(arr, ++lessR, index++);
        } else if (arr[index] > arr[N - 1]) {
            swap(arr, --moreL, index);
        } else {
            index++;
        }
    }
    swap(arr, moreL, arr[N - 1]);
}
```


### 快排

#### 基本函数partition

```java
// arr[L...R]范围上, 拿arr[R]做划分值
// L....R     <   =   >
// 返回等于区域的左边界跟右边界
public static int[] partition(int[] arr, int L, int R) {
    int lessR = -1;
    int moreL = R;
    int index = L;
    // arr[N-1]
    while (index < moreL) {
        if (arr[index] < arr[R]) {
            swap(arr, ++lessR, index++);
        } else if (arr[index] > arr[R]) {
            swap(arr, --moreL, index);
        } else {
            index++;
        }
    }
    swap(arr, moreL, arr[R]);

    return new int[]{lessR + 1, moreL};
}
```

#### 快排-递归版本

```java
public static void quickSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    process(arr, 0, arr.length - 1);
}

public static void process(int[] arr, int L, int R) {
    if (L >= R) { // 等于的时候不用排序
        return;
    }    
    // L < R
    swap(arr, L + (int) (Math.random() * (R - L + 1)), R);
    int[] equalArea = netherlandsFlag(arr, L, R);
    // equalArea[0] 等于区域第一个数
    // equalArea[1] 等于区域最后一个数
    process(arr, L, equalArea[0] - 1);
    process(arr, equalArea[1] + 1, R);
}
```


#### 快排-非递归版本

假设101个数排序   
一个任务就是一个L 和 一个 R, 最大的任务是 0~100这个任务   
![[Pasted image 20210204194654.png]]

```java
public static void quickSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    Stack<Job> stack = new Stack<>();
    stack.push(new Job(0, arr.length - 1)); // 最大的任务
    while (!stack.isEmpty()) {
        Job cur = stack.pop();
        int[] equals = partition(arr, cur.L, cur.R);
        if(equals[0] > cur.L) { // 有小于区域, 才有子任务
            stack.push(new Job(cur.L, equals[0] -1));
        }
        if(equals[1] < cur.R) { // 有大于区域, 才有子任务
            stack.push(new Job(equals[1] + 1, cur.R));
        }
    }
}
```

