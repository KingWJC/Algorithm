# 排序算法

### 排序算法稳定性

稳定性是指同样大小的样本，在排序之后不会改变相对次序。

1. 对于基础类型，稳定性无意义
2. 对于非基础类型，稳定性很重要
   1. 比如淘宝中，先用价格从300-500范围内从小到大排序，再使用好评度排序，如果两次排序时稳定的，则最终结果里第一个物品是物美价廉的。
3. 有些排序算法是无法改写成稳定的。如：
   1. 选择排序（**不稳定**）：选择最小值放在0位置，最后一个值可能会越过相同的值到最左的位置。
   2. 冒泡，插入，可以实现成**稳定**的，在两两比较的时候，处理相等的情况（相等不交换，或往前插入）
   3. 归并（相等时，先拷贝左组的数，能保证顺序**稳定**）
   4. 快排（不稳定）：partition不能稳定，小于等于区扩充时，小于等于区的下一个位置会和当前遍历的位置进行交换，不能处理相等情况。
   5. 堆排序：数组调成大根堆不稳定，是树结构，顺序调整：是和父（子）节点的值进行比较。
   6. 桶排序的样本数据限制为正整数，稳定性无意义。

### 排序算法总结

|          | 时间复杂度 | 额外空间复杂度 | 稳定性 |
| -------- | ---------- | -------------- | ------ |
| 选择排序 | O(N^2)     | O(1)           | 无     |
| 冒泡排序 | O(N^2)     | O(1)           | 有     |
| 插入排序 | O(N^2)     | O(1)           | 有     |
| 归并排序 | O(N* logN) | O(N)           | 有     |
| 随机快排 | O(N* logN) | O(logN)        | 无     |
| 堆排序   | O(N* logN) | O(1)           | 无     |
|          |            |                |        |
| 计数排序 | O(N)       | O(M)           | 有     |
| 基数排序 | O(N)       | O(N)           | 有     |

1. 不基于比较的排序，对样本数据有严格要求，不易改写  
2. 基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用 
3.  基于比较的排序，时间复杂度的极限是O($N*logN$)  *
4. *时间复杂度O($N*logN$)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是**不存在**的。  
5. 为了绝对的速度选**快排**(算法的常数时间最小）、为了省空间选**堆排**、为了稳定性选**归并**  

### 常见的坑

1. 归并排序的额外空间复杂度可以变成O(1)，“归并排序 内部缓存法”，但是将变得不再稳定。
       ==> 可以, 方法很难, 都不稳定了, 为什么不用堆排序?

2. “原地归并排序" 是垃圾贴，会让时间复杂度变成O(N^2) 
       ==> 额外空间复杂度可以变成O(1), 但让时间复杂度退变成N^2, 用插入排序多好

3. 快速排序稳定性改进，“01 stable sort”，但是会对样本数据要求更多。
      ==> 可以, 要求对数据范围做限制, 快排就是基于比较的排序, 对数据状况做限制, 为什么不用不基于比较的桶排序呢?

题目：在无序的整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变。有没有时间复杂度做到O(N)，额外空间复杂度做到O(1)的方法。

- 需要自我更新成要求的样子，快排中的partition，小于等于放左，大于某个数放右，**01标准**，只有两个结果。所以这个题目也是一个01标准的问题。
- 而快排是无法做到的，所以没有可以实现的方法。

### 工程上对排序的改进

1) 稳定性的考虑 ，如：
   1) Java中实现的系统排序的改进：Arrays.sort()中的源码，反射后如果是基础类型，会使用快排，若是非基础类型，使用归并。

2) 充分利用O(N*logN)和O(N^2)排序各自的优势

   ```java
   //经典快排的改进，结合数据量小的时候，插排的常数项优势，数据量大时，快排的调度优势
   public static void quickSort(int[] arr)
   {
       if(L+60>R)
       {
           //不足60个时，使用插入排序。
           return;
       }
       int[] equalArr=partition(arr,l,r);
       quickSort(arr,l,equalArr[0]-1);
       quickSort(arr,equalAll[1]+1,r);
   }
   ```

   插入排序的常数项小，调度优势差O(N^2)，但快排的常数项高,调度优势大O(N*logN)。
   
   所以数据量大的时候，调度优势明显，而数据量小的时候，比较小的常数项可能会胜出。
   
   通过实验得出模数60.

