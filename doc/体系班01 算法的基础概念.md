# 01 算法的基础概念

算法和数据结构学习的大脉络，所有的题目讲解，对于大脉络的实践贯穿始终

1）知道怎么算的算法

2）知道怎么试的算法。 图灵，大部分算法。

评估算法优劣的核心指标：

1. 时间复杂度（流程决定）

2. 额外空间复杂度（流程决定）

3. 常数项时间（实现细节决定）

## 时间复杂度 

时间复杂度：就是常数时间的操作。

### 常数时间的操作

常数时间的操作是指：如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。

常见的常数时间的操作：

- 常见的算术运算（+、-、*、/、% 等）
- 常见的位运算（>>、>>>、<<、|、&、^等）
- 赋值、比较、自增、自减操作等
- 数组寻址操作

总之，执行时间固定的操作都是常数时间的操作。

反之，执行时间不固定的操作，都不是常数时间的操作。

### 估算

1. 确定算法流程的总操作数量与样本数量之间的表达式关系。

   1，想象该算法流程所处理的数据状况，要按照最差情况来。

   2，把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作。

   3，如果数据量为N，看看基本动作的数量和N是什么关系。

2. 当完成了表达式的建立，只要把**最高阶项**留下即可。低阶项都去掉，高阶项的系数也去掉。记为：O(忽略掉系数的高阶项)


### 常见的时间复杂度

排名从好到差：

- O(1)    
- O(logN)    
- O(N)   
- O(N* logN)   
- O(N^2)   O(N^3)   …   O(N^K)  
- O(2^N)   O(3^N)   …   O(K^N)  
- O(N!)  

### 注意

1，算法的过程，和具体的语言是无关的。

2，想分析一个算法流程的时间复杂度的前提，是对该流程非常熟悉

3，一定要确保在拆分算法流程时，拆分出来的所有行为都是常数时间的操作。这意味着你写算法时，对自己的用过的每一个系统api，都非常的熟悉。否则会影响你对时间复杂度的估算。

### 意义

时间复杂度的意义在于：

当我们要处理的样本量很大很大时，我们会发现低阶项是什么不是最重要的；每一项的系数是什么，不是最重要的。真正重要的就是最高阶项是什么。

这就是时间复杂度的意义，它是衡量算法流程的复杂程度的一种指标，该指标只与数据量有关，与过程之外的优化无关。

## 实践

### 选择排序

过程：

- arr[0～N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。
- arr[1～N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。
- arr[2～N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。
- …
- arr[N-1～N-1]范围上，找到最小值位置，然后把最小值交换到N-1位置。

估算：

- 很明显，如果arr长度为N，每一步常数操作的数量，如等差数列一般
- 所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)
- 所以选择排序的时间复杂度为O(N^2)

### 冒泡排序

过程：

- 在arr[0～N-1]范围上：arr[0]和arr[1]，谁大谁来到1位置；arr[1]和arr[2]，谁大谁来到2位置…arr[N-2]和arr[N-1]，谁大谁来到N-1位置
- 在arr[0～N-2]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2]，谁大谁来到N-2位置
- 在arr[0～N-3]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到N-3位置
- …
- 最后在arr[0～1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1]，谁大谁来到1位置

估算：

- 很明显，如果arr长度为N，每一步常数操作的数量，依然如等差数列一般
- 所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)
- 所以冒泡排序的时间复杂度为O(N^2)。

### 插入排序

过程：

- 想让arr[0~0]上有序，这个范围只有一个数，当然是有序的。
- 想让arr[0~1]上有序，所以从arr[1]开始往前看，如果arr[1]<arr[0]，就交换。否则什么也不做。
- …
- 想让arr[0~i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。
- 最后一步，想让arr[0~N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。

估算：这个算法流程的复杂程度，会因为数据状况的不同而不同。

- 如果某个算法流程的复杂程度会根据数据状况的不同而不同，那么你必须要按照最差情况来估计。
- 很明显，在最差情况下，如果arr长度为N，插入排序的每一步常数操作的数量，还是如等差数列一般
- 所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)
- 所以插入排序排序的时间复杂度为O(N^2)。

## 额外空间复杂度 

要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程：

- 作为输入参数的空间，不算额外空间。
- 作为输出结果的空间，也不算额外空间。
- 因为这些都是必要的、和现实目标有关的。所以都不算。


但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是**额外空间。**

如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。

返回一个数组的拷贝数组，则额外空间复杂度就是O(1)，因为生成的新数组是作为输出结果的空间，不算额外。

返回数组中出现次数最多的数，若建立map词频表，最差情况，数组中每个数都不一样，则map达到和数组一样大，则额外空间复杂度为O(n).

## 算法流程的常数项

时间复杂度这个指标，是忽略低阶项和所有常数系数的。

难道同样时间复杂度的流程，在实际运行时候就一样的好吗？ 当然不是。

时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。

冒泡在常数项上就不如插入排序。

**比拼方式：放弃理论分析，生成大样本随机数据直接测。**

**为什么不去理论分析？**

1. 不是不能纯分析，而是没必要。因为不同常数时间的操作，虽然都是固定时间，但还是有快慢之分的。

2. 比如，位运算的常数时间原小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。

3. 所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，不如交给实验数据好了。

4. 比如: 快排的常数项比归并，堆要好。后面说的是它和插入比，就不行了。看跟谁比。

## 一个问题的最优解

一般情况下，认为解决一个问题的算法流程，在时间复杂度的指标上，一定要尽可能的低，先满足了时间复杂度最低这个指标之后，使用最少的空间的算法流程，叫这个问题的最优解。

一般说起最优解都是忽略掉常数项这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。（所以不包含常数优化，常数时间的操作最小）

## 对数器 

方便对方法进行测试，以及查找引发错误的原因。

1. 你想要测的方法a
2. 实现复杂度不好但是容易实现的方法b
3. 实现一个随机样本产生器
4. 把方法a和方法b跑相同的随机样本，看看得到的结果是否一样
5. 如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a和方法b
6. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确。 

## 二分法 

经常在一个有序数组上，开展二分搜索，查找结果。

但有序不是所有问题求解时，使用二分的必要条件。

只要能正确构建左右两侧的淘汰逻辑，就可以二分。

1) [[在一个有序数组中，找某个数是否存在]]
2) [[在一个有序数组中，找大于等于某个数最左侧的位置]]
3) [[在一个有序数组中，找小于等于某个数最右侧的位置]]
4) [[局部最小值问题]] ，在无序的数组中二分。

## 异或运算

异或运算就记成无进位相加 ：

1) 异或运算：相同为0，不同为1
2) 同或运算：相同以1，不同为0

异或运算的性质，满足交换律和结合率 ：

- 0^N == N      
- N^N == 0  
- M^(N^X) == (M^N)^X

题目:

- 题目1: [[如何不用额外变量交换两个数]] 

- 题目2: [[一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数 ]]  

- 题目3: [[提取整形数最右侧的1]]  

  - 对原数0000 0110取反,将原数右侧1右边的0位全变成了1(1111 1001), 
  - 这时候如果加1,会产生进位到原数右侧非零位,信息得以记录,
  - 再与原数与操作,即可将1提取

- 题目4: [[一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数 ]] 

- 题目5: [[一个数组中有一种数出现K次，其他数都出现了M次，M > 1, K < M, 找到，出现了K次的数，

  要求，额外空间复杂度O(1)，时间复杂度O(N)]]
