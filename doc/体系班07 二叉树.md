# 树形结构

定义：将一棵树进行180度大翻转，就成了数据结构中的树形结构。

1. 二叉树的每个节点，最多有两个分支。
2. 多叉树的每个节点，可以有任意分枝。

![img](https://img-blog.csdnimg.cn/20200105093213661.png)

实例：文件夹管理，就是树形结构，可以提高文件的查找效率。

## 基本概念

1. **根节点**：位于树中最顶端的节点就是整棵树的根节点。

2. **节点**：上图树中每个圆圆的就是节点。

3. **父节点和子节点**：一个节点分叉出来的就是该节点的子节点，而该节点就是这些子节点的父节点

4. **兄弟节点**：同属一个父亲的节点相互称为兄弟节点。

5. **子树，左子树、右子树**：一棵树中由很多小小的子树组成，如果一个节点的分枝有左右之分，那么一个节点的左分枝构成的子树则称为左子树，一个节点右分枝构成的子树为右子树

   1. 一棵树可以没有任何节点，称为空树
   2. 一棵树可以只有一个节点，也就只有根节点

6. **节点的度：**一个节点的子树的个数。

7. **树的度：**所有节点度中的最大值。

8. **叶子节点：**度为0的节点。

9. **非叶子节点：**度不为0的节点。

10. **层数：**根节点在第1层，根节点的子节点在第2层，以此类推（有些教材也从第0层开始算）

11. **节点的深度：**从根节点到当前节点的唯一路径上的节点总数

    **节点的高度：**从当前节点到最远叶子节点的路径上的节点总数。

    ![img](https://img-blog.csdnimg.cn/20200105105437146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjAxNzQz,size_16,color_FFFFFF,t_70)

    上图树中2号节点的深度为2，高度为3，因为从根节点到2号节点的唯一路径上的节点总数为2，从2号节点到最远叶子节点(13、14或15)的路径上的节点总数为3。

12. **树的深度**：所有节点深度中的最大值，很明显，该树的深度为4，从根节点到13、14或者15节点路径上的节点总数是4，而13、14、15**叶子节点**的深度是树中所有**节点深度中的最大值**。

    **树的高度**：所有节点高度中的最大值，很明显，该树的高度也为4，13、14或15是最远叶子节点，从根节点到这三个最远叶子节点的路径上的节点总数是4，而**根节点的高度**是树中所有**节点高度中的最大值。**

    **树的深度等于树的高度**。

# 二叉树

## 定义

- **每个节点的度最大为2（最多拥有两棵子树）**
- **左子树和右子树是有顺序的**
- **即使某节点只有一棵子树，也要区分左右子树**

```java
// 结构描述
class Node<V>{
    V value;
    Node<V> left;
    Node<V> right;
}
```

## 性质

- 非空二叉树的第i层，最多![2^{i-1}](https://private.codecogs.com/gif.latex?2%5E%7Bi-1%7D)个节点（![i\geq1](https://private.codecogs.com/gif.latex?i%5Cgeq1)）
- 在高度为h的二叉树上最多有![2^{h} - 1](https://private.codecogs.com/gif.latex?2%5E%7Bh%7D%20-%201)个节点（![h\geq 1](https://private.codecogs.com/gif.latex?h%5Cgeq%201)），即先计算每层最多节点，然后h层相加结果![2^{0} + 2^{1} + 2^{3} + ......+ 2^{h-1} = 2^{h} -1](https://private.codecogs.com/gif.latex?2%5E%7B0%7D%20&plus;%202%5E%7B1%7D%20&plus;%202%5E%7B3%7D%20&plus;%20......&plus;%202%5E%7Bh-1%7D%20%3D%202%5E%7Bh%7D%20-1)（等比数列求和公式）
- 对于任何一课非空二叉树，如果叶子节点个数为n0，度为2的节点个数为n2，则有n0 = n2 + 1.

## 类别

1. 真二叉树（Proper Binary Tree)，所有节点的度都要么为0，要么为2。

2. 满二叉树（Full Binary Tree)，所有节点的度要么为0，要么为2，且所有的叶子节点都在最后一层。

   假设满二叉树的高度为![h](https://private.codecogs.com/gif.latex?h)（![h\geq 1](https://private.codecogs.com/gif.latex?h%5Cgeq%201))，那么

   1. 第![i](https://private.codecogs.com/gif.latex?i)层的节点数量为：![2^{i-1}](https://private.codecogs.com/gif.latex?2%5E%7Bi-1%7D)
   2. 叶子节点数量为：![2^{h-1}](https://private.codecogs.com/gif.latex?2%5E%7Bh-1%7D)
   3. 总节点数量![n](https://private.codecogs.com/gif.latex?n)，![n = 2^{h} -1 = 2^{0} + 2^{1} + 2^{3} + ......+ 2^{h-1}](https://private.codecogs.com/gif.latex?n%20%3D%202%5E%7Bh%7D%20-1%20%3D%202%5E%7B0%7D%20&plus;%202%5E%7B1%7D%20&plus;%202%5E%7B3%7D%20&plus;%20......&plus;%202%5E%7Bh-1%7D)，![h=\log (n+1)](https://private.codecogs.com/gif.latex?h%3D%5Clog%20%28n&plus;1%29)，![\log](https://private.codecogs.com/gif.latex?%5Clog)的底为2.

   - 在同样高度的二叉树中，满二叉树的叶子节点数量最多，总节点数量最多
   - 满二叉树一定是真二叉树，真二叉树不一定是满二叉树

3. **完全二叉树(Complete Binary Tree)**：叶子节点只会出现在最后2层，且最后一层的叶子节点都靠左对齐。

   1. 简单来说，就是所有节点从上往下，从左往右依次排列。
      - 完全二叉树从根节点到倒数第2层是一棵满二叉树
      - 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树
      - 度为1的节点只有左子树
      - 度为1的节点要么是1个，要么是0个
   2. 假设完全二叉树的高度为![h](https://private.codecogs.com/gif.latex?h)（![h\geq 1](https://private.codecogs.com/gif.latex?h%5Cgeq%201)），那么
      1. 至少有![2^{h-1}](https://private.codecogs.com/gif.latex?2%5E%7Bh-1%7D)个节点（![2^{0} + 2^{1} + 2^{3} + ......+ 2^{h-2}+1](https://private.codecogs.com/gif.latex?2%5E%7B0%7D%20&plus;%202%5E%7B1%7D%20&plus;%202%5E%7B3%7D%20&plus;%20......&plus;%202%5E%7Bh-2%7D&plus;1)）![img](https://img-blog.csdnimg.cn/20200105120623331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjAxNzQz,size_16,color_FFFFFF,t_70)
      2. 至多有![2^{h} -1](https://private.codecogs.com/gif.latex?2%5E%7Bh%7D%20-1)个节点（![2^{0} + 2^{1} + 2^{3} + ......+ 2^{h-1}](https://private.codecogs.com/gif.latex?2%5E%7B0%7D%20&plus;%202%5E%7B1%7D%20&plus;%202%5E%7B3%7D%20&plus;%20......&plus;%202%5E%7Bh-1%7D)，满二叉树）![img](https://img-blog.csdnimg.cn/20200105120649620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxNjAxNzQz,size_16,color_FFFFFF,t_70)
      3. 总结点数量为 n，![2^{h-1}\leq n < 2^{h}](https://private.codecogs.com/gif.latex?2%5E%7Bh-1%7D%5Cleq%20n%20%3C%202%5E%7Bh%7D)，因此![h-1\leqslant \log n< h](https://private.codecogs.com/gif.latex?h-1%5Cleqslant%20%5Clog%20n%3C%20h)，推出![h = floor(\log n) + 1](https://private.codecogs.com/gif.latex?h%20%3D%20floor%28%5Clog%20n%29%20&plus;%201)，floor为向下取整，另外ceiling是向上取整。
   3. 如果一棵完全二叉树有768个节点，求叶子节点的个数
      1. 令二叉树中叶子个数为L，只有一个孩子的结点数为S， 有两个孩子的结点数为D，所有结点数位n，则有1） 
      2. 原因是除根结点外每个叶子结点都由一条入边， 且该入边是由其父节点引出的，根据完全二叉树的性质可知S=0或S=1， 从n=768可知 s=1
      3. n=L+S+D。n-1=2D+S，

## 先、序、后序遍历

1. 先序：任何子树的处理顺序都是，先头节点、再左子树、然后右子树
2. 中序：任何子树的处理顺序都是，先左子树、再头节点、然后右子树
3. 后序：任何子树的处理顺序都是，先左子树、再右子树、然后头节点

**递归实现**

1. 理解递归序  (一个节点)

2. 先序、中序、后序都可以在递归序的基础上加工出来  

3. 第一次到达一个节点就打印就是先序、第二次打印即中序、第三次即后序  

**非递归实现**

1. 任何递归函数都可以改成非递归  
2. 自己设计压栈的来实现  



## 题目

- 二叉树某一节点X祖先节点的交集

- [[递归方式实现二叉树的三序遍历]]

- [[非递归方式实现二叉树的三序遍历]]

- [[实现二叉树的按层遍历]]   

  1）其实就是宽度优先遍历，用队列

  2）可以通过设置flag变量的方式，来发现某一层的结束（看题目）

- [[不给头结点,删除单链表上的节点]]   

- 431.[[将 N 叉树编码为二叉树]] [H]  
  https://leetcode-cn.com/problems/encode-n-ary-tree-to-binary-tree

- [[二叉树的序列化和反序列化]]  

  1）先序方式序列化和反序列化

  ​	1）可以用先序或者中序或者后序或者按层遍历，来实现二叉树的序列化

  ​    2）用了什么方式序列化，就用什么样的方式反序列化

  ​    3）中序遍历无法实现序列化和反序列化

  2）按层方式序列化和反序列化

- [[如何设计一个打印整棵树的打印函数]]  

- [[求二叉树最宽的层有多少个节点]]  

- [[二叉树中指定节点的后继节点 ]]  

  ```java
  //二叉树结构如下定义：
  Class Node {
  	V value;
  	Node left;
  	Node right;
  	Node parent;
  }
  ```

- [[从上到下打印对折纸条所有折痕的方向]]:  

  请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。 

  给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。 

  例如:N=1时，打印: down N=2时，打印: down down up 

# 二叉树的递归套路

#BST   
#二叉树    
#树型dp   
#动态规划    
#二叉树的递归套路 

---

## 二叉树的递归套路

可以解决面试中绝大多数的二叉树问题尤其是[[树型DP]]问题

本质是利用递归遍历二叉树的便利性

1）假设以X节点为头，假设可以向X左树和X右树要任何信息  
2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）  
3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息  
4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S  
5）递归函数都返回S，每一棵子树都这么要求  
6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息  

### 二叉树的递归套路深度实践

给定一棵二叉树的头节点head，

- 题目1: [[判断二叉树是不是平衡二叉树]]

- 题目2: [[判断二叉树是不是满二叉树]]

- 题目3: [[判断二叉树是不是搜索二叉树]]

- 题目4: [[二叉树中最大的二叉搜索子树的大小]]

- 题目5: [[二叉树中最大的二叉搜索子树的头节点]]

- 题目6: [[判断二叉树是不是完全二叉树]]

  - 用二叉树的递归套路来解这个题

- 题目7: [[二叉树上两个节点的最低公共祖先]]

- 题目8: [[任何两个节点之间都存在距离，求二叉树两个节点的最大距离]]

- 题目9: [[派对的最大快乐值]]

  ```
  员工信息的定义如下:
  class Employee {
      public int happy; // 这名员工可以带来的快乐值
      List<Employee> subordinates; // 这名员工有哪些直接下级
  }
  派对的最大快乐值
   公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。 叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。
   这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：
  1.如果某个员工来了，那么这个员工的所有直接下级都不能来
  2.派对的整体快乐值是所有到场员工快乐值的累加
  3.你的目标是让派对的整体快乐值尽量大
  给定一棵多叉树的头节点boss，请返回派对的最大快乐值。
  
  
  ```

  
