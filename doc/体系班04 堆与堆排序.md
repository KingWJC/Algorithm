## 比较器

1. 比较器的实质就是重载比较运算符 

2) 比较器可以很好的应用在特殊标准的排序上 

3) 比较器可以很好的应用在根据特殊标准排序的结构上

4) 写代码变得异常容易，还用于范型编程 

任何**比较器的统一约定**，即如下方法：

```java
@Override
public int compare(T o1, T o2) ;

// 返回负数的情况，就是o1比o2优先的情况
// 返回正数的情况，就是o2比o1优先的情况
// 返回0的情况，就是o1与o2同样优先的情况
```

## 堆结构

1. 堆结构就是用数组实现的完全二叉树结构

   想像中的二叉树.

   任何一个i位置, 它的**左节点索引位置是2*i+1, 右节点是2\*i+2, 父节点是(i-1)/2.**

2. 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆

3. 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆

4. 堆结构的heapInser向上调整,与heapify向下调整操作

   若堆中有index位置的数错误, 调用一次heapInser和heapify, 堆还是大根堆

   操作的时间复杂度是O(logN), 移动的步骤数是和**堆的高度相关logN**. (heapify只向一侧沉), 

5. 堆结构的增大和减少 

6. 优先级队列结构，就是堆结构 

**语言提供的堆结构 vs 手写的堆结构**

1. 取决于，你有没有动态改信息的需求！

2. 语言提供的堆结构，如果你动态改数据，不保证依然有序

3. [[手写堆]]，因为增加了对象的位置表，所以能够满足动态改信息的需求

## 堆排序

1. 先让整个数组都变成大根堆结构，建立堆的过程:       
   1. 从上到下的方法，时间复杂度为O(N \* logN)   

      使用数据量扩倍法：N个数和2N个数的复杂度一样。（忽略常数项）

      1.  N个数放入堆中得到复杂度上限：O(N*logN)
      2. 2N个数放入堆，先是N个数入堆，高度是logN，则得到复杂度下限O(N*logN)
      3. 上限，下限一样，则时间复杂度为O(N \* logN)   

   2. 从下到上的方法，时间复杂度为O(N)   

      从下到上的操作数为：
   
      第一层：有N/2个节点，因为是叶子节点，每个节点执行heapify为1次。
   
      第二层：有N/4个节点，每个节点往下沉只有一层，所以每个节点执行heapify为2次。
   
      ............... 可得**等比数列求和公式**(q=0.5)：**错位相减法**。
      $$
      \begin{align}
      S(N) &= \frac N2 *1+\frac N4*2+\frac N8*3+\dots\frac{N}{2^n}*N\\
      2*S(N) &= N*1+\frac N2*2+\frac N4*3+\dots\frac{N}{2^{n-1}}*N \\
      S(N) &= 2S(N)-S(N) \\
       &=N+\frac N2+\frac N4 +\dots\frac{N}{2^{n-1}}*N \\
       &=\frac{1-q^n}{1-q} * N   (q=\frac 12)
       \end{align}
      $$
   
   3. 区别是：完全二叉树是一个三角形，数的宽度是越来越大。
   
      从上到下：大量节点是高度增加之后加上去的，O(N*LogN)。 
   
      从下往上：大量的节点是层数少的，少量的节点是层数高的。O(N),   
   
      经典的堆结构需要heapinsert, heapify,需要一个个数的增加，用临时的数来建堆，只能使用从上往下建堆
   
      堆排序中，一次得到所有数。只需要有heapify，使用从下往上建堆。
   
2. 把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N \* logN)   
3. 堆的大小减小成0之后，排序完成   

**题目**

- [[相对几乎有序数组排序]]，已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。

  请选择一个合适的排序策略，对这个数组进行排序。  **使用K个大小的小根堆**。

