## 比较器

1. 比较器的实质就是重载比较运算符 

2) 比较器可以很好的应用在特殊标准的排序上 

3) 比较器可以很好的应用在根据特殊标准排序的结构上

4) 写代码变得异常容易，还用于范型编程 

任何**比较器的统一约定**，即如下方法：

```java
@Override
public int compare(T o1, T o2) ;

// 返回负数的情况，就是o1比o2优先的情况
// 返回正数的情况，就是o2比o1优先的情况
// 返回0的情况，就是o1与o2同样优先的情况
```

## 堆结构

1. 堆结构就是用数组实现的完全二叉树结构

   想像中的二叉树.

   任何一个i位置, 它的**左节点索引位置是2*i+1, 右节点是2\*i+2, 父节点是(i-1)/2.**

2. 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆

3. 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆

4. 堆结构的heapInser向上调整,与heapify向下调整操作

   若堆中有index位置的数错误, 调用一次heapInser和heapify, 堆还是大根堆

   操作的时间复杂度是O(logN), 移动的步骤数是和**堆的高度相关logN**. (heapify只向一侧沉), 

5. 堆结构的增大和减少 

6. 优先级队列结构，就是堆结构 

**语言提供的堆结构 vs 手写的堆结构**

1. 取决于，你有没有动态改信息的需求！

2. 语言提供的堆结构，如果你动态改数据，不保证依然有序

3. [[手写堆]]，因为增加了对象的位置表，所以能够满足动态改信息的需求

## 堆排序

1. 先让整个数组都变成大根堆结构，建立堆的过程:       
   1. 从上到下的方法，时间复杂度为O(N \* logN)   

      加入N个数, 最大高度时才是logN,, 每一次加数的时间复杂度logN是变化的,动态增加的. :

      如:  log1+log2+log3......logN
   
      动态的操作如何估计复杂度: 使用数据量增加常数(扩倍)法：N个数和2N个数的复杂度一样。（忽略常数项）

      1.  N个数放入堆中得到复杂度上限：O(N*logN)
      2. 2N个数放入堆，先是N个数入堆，高度是logN，则得到复杂度下限O(N*logN)
      3. 上限，下限一样，则时间复杂度为O(N \* logN)   
   
   2. 从下到上的方法，时间复杂度为O(N)   
   
      从下到上的操作数为：
   
      第一层：有N/2个节点，因为是叶子节点，每个节点执行heapify为1次。
   
      第二层：有N/4个节点，每个节点往下沉只有一层，所以每个节点执行heapify为2次。
   
      ............... 可得**等比数列求和公式**(q=0.5)：**错位相减法**。
      $$
      \begin{align}
      S(N) &= \frac N2 *1+\frac N4*2+\frac N8*3+\dots\frac{N}{2^n}*N\\
      2*S(N) &= N*1+\frac N2*2+\frac N4*3+\dots\frac{N}{2^{n-1}}*N \\
      S(N) &= 2S(N)-S(N) \\
       &=N+\frac N2+\frac N4 +\dots\frac{N}{2^{n-1}}*N \\
       &=\frac{1-q^n}{1-q} * N   (q=\frac 12)
       \end{align}
      $$
   
   3. 区别是：完全二叉树是一个三角形，数的宽度是越来越大。
   
      从上到下：大量节点是高度增加之后加上去的，O(N*LogN)。 
   
      从下往上：大量的节点是层数少的，少量的节点是层数高的。O(N),   
   
      经典的堆结构需要heapinsert, heapify,需要一个个数的增加，用临时的数来建堆，只能使用从上往下建堆
   
      堆排序中，一次得到所有数。只需要有heapify，使用从下往上建堆。
   
2. 把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N \* logN)   

3. 堆的大小减小成0之后，排序完成   

**题目**

- [[相对几乎有序数组排序]]，已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。

  请选择一个合适的排序策略，对这个数组进行排序。  **使用K个大小的小根堆**。

- 最大线段重合问题-堆实现

  - 线段数组从小到大排序,并遍历.

  - 若重合区域用当前线段的开始位置做左边界, 有多少线段是穿过相同的左边界住右沿续

  - 小根堆中记录之前线段的结束位置与当前线段的重合, 则结束位置必须大于线段开始位置

  - 所以若小根堆中, 有小于等于线段开始位置的值, 则弹出.

  - 将结束位置的数放入小根堆中, 小根堆中有几个数, 就是这个线段重合的个数.

  - 最大的就是最大线段重合数.

    

  - 多个线段重合,则重合区域的左边界必定是其中一个线段的左边界.

  - 所以可以通过计算每一个线段的左边界为重合区域的左边界时, 线段的重合数.

## 补充

可以通过题目的数据规模, 推理时间复杂度符合的算法, 如在牛客网.

代码的指令条数在10^8~10^9内, 代码执行时间:

1. C/C++ 1-2S
2. Java/C#(有虚拟机) 2-4s
3. 脚本语言 2-4s

