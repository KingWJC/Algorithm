## 比较器

1. 比较器的实质就是重载比较运算符 

2) 比较器可以很好的应用在特殊标准的排序上 

3) 比较器可以很好的应用在根据特殊标准排序的结构上

4) 写代码变得异常容易，还用于范型编程 

任何**比较器的统一约定**，即如下方法：

```java
@Override
public int compare(T o1, T o2) ;

// 返回负数的情况，就是o1比o2优先的情况
// 返回正数的情况，就是o2比o1优先的情况
// 返回0的情况，就是o1与o2同样优先的情况
```

## 堆结构

1. 堆结构就是用数组实现的完全二叉树结构

   想像中的二叉树.

   任何一个i位置, 它的**左节点索引位置是2*i+1, 右节点是2\*i+2, 父节点是(i-1)/2.**

2. 完全二叉树中如果每棵子树的最大值都在顶部就是大根堆

3. 完全二叉树中如果每棵子树的最小值都在顶部就是小根堆

4. 堆结构的heapInser向上调整,与heapify向下调整操作

   若堆中有index位置的数错误, 调用一次heapInser和heapify, 堆还是大根堆

   操作的时间复杂度是O(logN), 移动的步骤数是和**堆的高度相关logN**. (heapify只向一侧沉), 

5. 堆结构的增大和减少 

6. 优先级队列结构，就是堆结构 

**语言提供的堆结构 vs 手写的堆结构**

1. 取决于，你有没有动态改信息的需求！

2. 语言提供的堆结构，如果你动态改数据，不保证依然有序

3. [[手写堆]]，因为增加了对象的位置表，所以能够满足动态改信息的需求

## 堆排序

1. 先让整个数组都变成大根堆结构，建立堆的过程:       
   1. 从上到下的方法，时间复杂度为O(N \* logN)   

      使用数据量扩倍法：N个数和2N个数的复杂度一样。（忽略常数项）

      1.  N个数放入堆中得到复杂度上限：O(N*logN)
      2. 2N个数放入堆，先是N个数入堆，高度是logN，则得到复杂度下限O(N*logN)
      3. 上限，下限一样，则时间复杂度为O(N \* logN)   

   2. 从下到上的方法，时间复杂度为O(N)   

2. 把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N \* logN)   
3. 堆的大小减小成0之后，排序完成   

**题目**

- [[相对几乎有序数组排序]]，已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。

  请选择一个合适的排序策略，对这个数组进行排序。 