# 暴力递归

暴力递归就是一个简单的递归尝试方法。 出现了一个问题，不知道是怎么解决的，但我们知道可以怎么一步一步进行尝试，在这一步步的尝试过程就可以把问题解决了。

尝试的方法，可以画决策图，也可以用黑盒思维：

1. 把问题转化为规模缩小了的同类问题的子问题
2. 规定**黑盒函数的含义**：包括输入，达到什么效果，遵循的限制条件。

2. 有明确的不需要继续进行递归的条件（base case不需要再分解问题）。

3. 有当得到了子问题的结果之后的决策过程，（如何使用黑盒函数）

4. 不记录每一个子问题的解

## 题目

熟悉什么叫**尝试**：

1. 打印n层汉诺塔从最左边移动到最右边的全部过程

2. 打印一个字符串的全部子序列（可以不连续）

   所有情况是一个二叉树，分支为是否包含当前顶点，如123.  1为顶点，2为1的子节点，3为2的子节点

3. 打印一个字符串的全部子序列，要求不要出现重复字面值的子序列

4. 打印一个字符串的全部排列（字符都要，但顺序不一样）

   深度优先遍历中的技巧：在方法**决策需要原始数据时，恢复现场**。

   两种方法：使用集合 或直接在字符串中交换位置。

5. 打印一个字符串的全部排列，要求不要出现重复的排列

   减支：提前减少分支，boolean[] visit=new boolean[256]

   过滤：Set。

6. 给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数。 如何实现? 

   揭示: 你想怎么试就能怎么写, 但必须保证子问题跟所描述的是一个事，一个大问题要拆成同样含义但数据量变小的子问题  

   但是, 尝试是有优劣的:  比如汉诺塔问题, 可以用6个递归  也可以做抽象化, 变成一个问题 

   重点是: 怎么设计一个尝试, 能够优化出最好版本  

# 动态规划

## 定义

什么暴力递归可以继续优化？

1. 有重复调用同一个子问题的解，这种递归可以优化
2. 如果每一个子问题都是不同的解，无法优化也不用优化

暴力递归和动态规划的关系：

1. 某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划
2. 任何动态规划问题，都一定对应着某一个有重复过程的暴力递归
3. 但不是所有的暴力递归，都一定对应着动态规划

面试题和动态规划的关系：

1. 解决一个问题，可能有很多尝试方法
2. 可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式
3. 一个问题**可能有**若干种动态规划的解法

**暴力递归之所以暴力是因为有大量重复计算在浪费时间**

**动态规划就是某一类尝试行为的进一步优化，任何一个动态规划的问题都是以某一个暴力尝试过程中优化后的样子**

## 步骤

**在递归写法中，找出可变参数， 再找出依赖项，再找出这个动态规划表中我们想要的是哪一块。** 找出不需要依赖其他项的，先填，也就是先填递归到底的情况和边界情况。

![Pasted image 20210504190038](images\Pasted image 20210504190038.png)

如何找到某个问题的动态规划方式：

1. 设计暴力递归：**重要原则+4种常见尝试模型**！重点！

   1）从左往右的尝试模型，如背包的bag的**明确的变化范围**。

   2）范围上的尝试模型：讨论范围的开头和结尾，结合的可能性。**明确的变化范围**

   3）多样本位置全对应的尝试模型：讨论两个样本的结尾结合的可能性。**明确的变化范围**

   4）寻找业务限制的尝试模型：不能够**直观的知道可变参数的变化范围**。 如咖啡机问题。
   	  **限制不够，业务来凑。**

2. 分析有没有重复解：

   列出调用过程，可以只列出前几层，有没有重复解，一看便知。

3. 用记忆化搜索 -> 用严格表结构实现动态规划：套路解决

4. 看看能否继续优化：动态规划的进一步优化

   1）空间压缩

   2）状态化简

   3）四边形不等式

   4）其他优化技巧

**面试**中设计暴力递归过程的重要原则：

1. 每一个可变参数的类型，一定不要比int类型更加复杂
2. 原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数
3. 如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可
4. 可变参数的个数，能少则少

知道了面试中设计暴力递归过程的原则，然后：

1. 一定要逼自己找到不违反原则情况下的暴力尝试！
2. 如果你找到的暴力尝试，不符合原则，马上舍弃！找新的！
3. 如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%！

暴力递归到动态规划的套路

1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用

2）找到哪些参数的变化会影响返回值，对每一个列出变化范围（**寻找递归中的可变参数**）

3）参数间的所有的组合数量，意味着表大小

4）记忆化搜索的方法就是傻缓存，非常容易得到

5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解

6）对于有枚举行为的决策过程，进一步优化

## 题目

### 斐波那契数列

 f(N)=f(N-1)+f(N-2); 求第N项的值，

- 相当于高度N的二叉树，每个节点都返回值，才能得到顶部的值。
- 尝试的暴力递归中有重复过程，可以加缓存进行优化。这个过程就是动态规划。
- 加缓存和顺序计算，时间复杂度都是O(N)。

### N皇后问题

假设有排成一行的N个位置，记为1~N，N 一定大于或等于 2

开始时机器人在其中的M位置上(M 一定是 1~N 中的一个)

如果机器人来到1位置，那么下一步只能往右来到2位置；

如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；

如果机器人来到中间位置，那么下一步可以往左走或者往右走；

规定机器人必须走 K 步，最终能来到P位置(P也是1~N中的一个)的方法有多少种

给定四个参数 N、M、K、P，返回方法数。

**分析**：方法数的数据：是一个有边界条件的二叉树。f(M ,K) = f(M-1 ,K-1) + f(M+1 ,K-1)

尝试：使用暴力递归完成。

优化：M，K能确认一个唯一的结果，所以使用二维缓存表，空间换时间，实现从顶向下的动态规划。

暴力递归中有重复计算，给其加缓存，下回遇到同样一个过程，直接从缓存中拿结果。 也叫**记忆化搜索（动态规划中最糙的一种，不关心状态的依赖）**

**示例**：N: 1~5,  M起始位置: 2，P目标位置: 4，K: 6，填充方法数的二维缓存表

| N位置(行) / K步 (列) |  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :------------------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|        **1**         |  0   |  0   |  0   |  1   |  0   |  4   |  0   |
|        **2**         |  0   |  0   |  1   |  0   |  4   |  0   |  13  |
|        **3**         |  0   |  1   |  0   |  3   |  0   |  9   |  0   |
|        **4**         |  1   |  0   |  2   |  0   |  5   |  0   |  14  |
|        **5**         |  0   |  1   |  0   |  2   |  0   |  5   |  0   |

当剩余步数K为0时，只有到达P: 4，则方法数为1.（base case)，**起始值为第一列**

当当前位置M为1时，只能往位置N: 2的走，总是依赖于下一行2位置的K-1的数据，所以f(1 ,K) = f(2 , K-1)

当当前位置M为5时，只能往位置N: 4的走，总是依赖于上一行2位置的K-1的数据，所以f(5 ,K) = f(4 , K-1)

其它位置：依赖于左下加左上的值。f(M ,K) = f(M-1 ,K-1) + f(M+1 ,K-1)

**结论**

二维动态规划表（状态转移），翻转后是一个会撞墙的杨辉三角形。

动态规划是结果，不是原因。每次的递归尝试，分析位置依赖，尝试的策略就是状态转移的方程。

尝试是自然智慧。是**范围上尝试的模型**。

实现：需要无效参数的总结。

### A,B玩家从左右两边拿纸牌,返回最后获胜者的分数

给定一个整型数组arr，代表数值不同的纸牌排成一条线

玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿

但是每个玩家每次只能拿走最左或最右的纸牌

玩家A和玩家B都绝顶聪明，请返回最后获胜者的分数。 

**分析：**AB同样聪明，每次选择都是最优的决策。

**A作为先手**，在arr的L到R上拿牌，获得最好分数的**决策**如下：

​		base case L==R  arr[L]直接拿走。

​		若拿走左侧的牌arr[L]，然后轮到后手在L+1到R上，获取最好的分数。

​		若拿走右侧的牌arr[R]，然后轮到后手在L到R-1上，获取最好的分数

​		选择两次结果的最大值返回。

**A作为后手**：在arr的L到R上拿牌，获得最好分数的**决策**如下：

​		base case L==R  **arr[L]会被B拿走**，只能拿到0。

​		若左侧的牌arr[L]被B拿走，然后轮到先手在L+1到R上，获取最好的分数。

​		若右侧的牌arr[R]被B拿走，然后轮到先手在L到R-1上，获取最好的分数

​		选择两次结果的最小值返回。  因为**B作为先手会把最大的拿走，只会剩下最小的**。

优化1： f(0,7) -> g(1,7)  &  g(0,6) ->  { f(1,6)  &  f(2,7) }  &  { f(1,6)  & f(0,5) }  

​			如上所示， f(1,6) 的计算重复，使用记忆化搜索。 两个二维表，记录先手，后手的分数。

优化2：用严格表结构实现动态规划

**示例**

[50，100，20，10]，只能从左或右选择一张牌

先手：10，100；后手：50，20。 获胜者的分数是110.

[7，4，16，15，1] 的先手，后手，在L到R上的最好分数，的二维动态规划表。

| (先手）L/R | 0    | 1    | 2    | 3    | 4    |
| :--------: | ---- | ---- | ---- | ---- | ---- |
|   **0**    | 7    | 7    | 20   | 23   | 24   |
|   **1**    | X    | 4    | 16   | 19   | 19   |
|   **2**    | X    | X    | 16   | 16   | 17   |
|   **3**    | X    | X    | X    | 15   | 15   |
|   **4**    | X    | X    | X    | X    | 1    |

| （后手）L/R | 0    | 1    | 2    | 3    | 4    |
| :---------: | ---- | ---- | ---- | ---- | ---- |
|    **0**    | 0    | 4    | 7    | 19   | 19   |
|    **1**    | X    | 0    | 4    | 16   | 17   |
|    **2**    | X    | X    | 0    | 15   | 15   |
|    **3**    | X    | X    | X    | 0    | 1    |
|    **4**    | X    | X    | X    | X    | 0    |

1. 对角线表示只剩一张牌，先手的对角线是当前位置的值，后手的对角线是0。 **起始值为对角线**

2. L不能小于R，所以表格下半部分都是X。

3. 按对角线的上一条线，进行填充值。先手表的值需要在后手表中，找对称点，然后L位置的值加上对称点下边的值，R位置的值加上对称点前面的值， 取最大值。

   dpf  = Math.max( arr[L]+dpg\[L+1\]\[R\],  arr[R]+dpg\[L\]\[R-1\] )

   dpg = Math.min( dpf\[L+1\]\[R\],  dpf\[L\]\[R-1\] )

4. **后手的计算，不需要加arr[L]或arr[R], 因为已被对手拿走**

**结论：**

属于**零和博弈**又称“*零和*游戏”，是博弈论的一个概念，属非合作*博弈*，指参*与博弈*的各方，在严格竞争下，一方的收益必然意味着另一方的损失，博弈各方的收益和损失相加总和永远为“零”。

尝试策略和状态转移方程是一回事。

在arr的L到R上尝试，是**范围上尝试的模型**。

### 背包能装下最多的价值

给定两个长度都为N的数组weights和values，

weights[i]和values[i]分别代表 i号物品的重量和价值。

给定一个正数bag，表示一个载重bag的袋子，

你装的物品不能超过这个重量，返回你能装下最多的价值是多少? 

**分析**

1. base case: 当货物重量大于背包重量时，这次的挑选无效。

2. 查找重复操作：可变参数（索引index和背包剩余的重量）

   W：[3，2，5]  V：[7，4，6]  bag=15。 

   P(0,15) -> 选择0和1，不选2，得P(3,10)；  不选择0和1，选择3，得P(3,10).  计算重复。

3. 动态转移方程就是尝试策略。(动态规划是暴力递归的返回值的一个缓存)

**示例**

bag=7,  W：[3，2，5]   V：[7，4，6] 

| **W\bag** | **0** | **1** | **2** | **3** | **4** | **5** | **6** | **7** |
| --------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| **0**     | 0     | 0     | 4     | 7     | 7     | 11    | 11    | 11    |
| **1**     | 0     | 0     | 4     | 4     | 4     | 6     | 6     | 10    |
| **2**     | 0     | 0     | 0     | 0     | 0     | 6     | 6     | 6     |
| **3**     | 0     | 0     | 0     | 0     | 0     | 0     | 0     | 0     |

1. bag剩余量小于0时，返回-1，结果无效，所以不展示。

2. 当W，V的索引为3时，没有货物，所以不管bag的余量还剩多少，都为0。  **起始值为最后一行**

3. 数据从下而上，填充每一行。

   f(0,7) = Math.max ( V[0] + f(1,4)，f(1,7) ).

**结论**

当W，V的索引，从左往右遍历，是**从左往右的尝试模型**。

### 数字转化为字符串的结果数

规定1和A对应、2和B对应、3和C对应...26和Z对应

那么一个数字字符串比如"111”就可以转化为："AAA"、"KA"和"AK"

给定一个只有数字字符组成的字符串str，返回有多少种转化结果 

**分析**

暴力尝试：

1. 使用**从右往左的尝试模型**，
2. 从index位置开始往后转换，index到达数字字符串的边界时，证明有一种转换结果。
3. 可变参数是Index位置。
4. 每次转换有两种方式：转换当前单个字符，转换当前字符和下一个字符。所以数据结构是一个二叉树。
5. 有重复操作：

从右往左的动态规划：**起始值为最后一个位置**

1. dp[i]表示：str[i...]有多少种转化方式。
2. 从后往前计算， 当前字符是判断字符串的前缀。
3. 只需判断前缀不能为0.  转换有两种方式。依赖dp[i+1]和dp\[i+2]

从左往右的动态规划：**起始值为第一个位置**

1. dp[i]表示：str[0...i]有多少种转化方式。
2. 从前往后计算，当前字符是判断字符串的后缀。
3. 后缀为0时，只能与前一个字符拼接。如果str[0...i-2]都不存在分解方案，那i和i-1拼成了也不行。
4. 后缀不为0，转换有两种方式。 依赖dp[i-1]和dp\[i-2]。与前一个字符拼接时，前一个字符不能为0。

### 贴纸拼词|多少张贴纸可以贴出给定字符串

给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文

arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来

返回需要至少多少张贴纸可以完成这个任务。

例子：str= "babac"，arr = {"ba","c","abcd"}，

两种方式：ba + ba + c 3    abcd + abcd 2    abcd + ba 2，所以返回最少2张。

**分析**

暴力尝试：

1. 字符串排序（提高命中率），肯定有某一张贴纸做为第一张，所以尝试所有的贴纸。
2. 第一张贴纸选ba，看之后总共需要几张贴纸。
3. 第二张贴纸选c，看之后总共需要几张贴纸。
4. 第三张贴纸选abcd，看之后总共需要几张贴纸。
5. 取最小的张数+1就是结果。也可能没有有效结果。

优化1：

1. 因为出现的字符都是小写英文，所以char[26]可以表示一个字符串中每个字符出现的次数。
2. 使用**词频统计表**（二维数组），代替贴纸数组，速度快。
3. 贪心策略：因为要完成任务，肯定有贴纸能消掉目标字符串的第一个字符，所以让只含有第一个字符的贴纸先试，不影响结果。不用每个贴纸都试。
4. 只有包含目标字符串的指定字符，才进行递归查找。**实现剪枝**。

优化2：**记忆化搜索优化**，没有必要改为严格表结构的动态规划

1. 因为可变参数是字符串，无法确定变化范围，临界值很多。
2. 不同于整型，整型的下标可以确定范围。
3. 所以只需要记忆化搜索。不用严格表结构的动态规划。

**结论**

这个题在所有的尝试中，地位很高。

**尽量做到使用严格位置依赖，像这个题只能用傻缓存**。因为很多进阶技巧来自整理好依赖后的进一步优化。

### 两个字符串的最长公共子序列

**子序列：可以不连续，且顺序不变的一串字符。**

**子串：必须连续，且顺序不变的一串字符。**

给定两个字符串str1和str2，返回这两个字符串的最长公共子序列长度

例子：str1 = “a12b3c456d”,str2 = “1ef23ghi4j56k”，最长公共子序列是“123456”，所以返回长度6。

**分析**

是**样本对应的尝试模型**，它的经验是**往往讨论当前样本范围的结尾该如何组织可能性**。

Str1[0.....i]，Str2[0....j] 两个字符串的公共子序列，i!=0&&j!=0时的可能性如下：

1. 公共子序列不考虑i位置的字符，即不以 i 结尾，但有可能考虑j位置

2. 公共子序列不考虑j位置的字符，即不以 j 结尾，但有可能考虑i位置

   两种可能性有重叠，即不考虑i位置，也不考虑j位置，因为是求最大，所以不影响。

3. i位置的字符== j位置的字符，公共子序列的结尾是i位置的字符。

可能性也可以是：

1. 公共子序列不考虑i位置的字符，也不考虑j位置的字符。
2. 公共子序列不考虑i位置的字符，但一定是以j结尾。
3. 和上一种方式相比，一定是以j结尾，可能性讨论变的麻烦，因为需要验证Str1中有没有j位置的字符。

动态规划：

1. 两个可变参数i和j，所以使用一个二维表能存储每个位置的结果。
2. 从递归尝试中分析依赖，一个位置的结果需要三个已算好的位置（左，左上，上）
3. 先计算第一行和第一列的值，则之后的结果从上到下，每行的值都可以计算。 
4. **起始值为第一行和第一列** ，str1="a1bc" str2="ef1b"  1b.

| Str1[i]/Str2[j] | 0    | 1    | 2    | 3    |
| :-------------: | ---- | ---- | ---- | ---- |
|      **0**      | 0    | 0    | 0    | 0    |
|      **1**      | 0    | 0    | 1    | 1    |
|      **2**      | 0    | 0    | 1    | 2    |
|      **3**      | 0    | 0    | 1    | 2    |

**结论**

是**样本对应的尝试模型**，它的经验是**往往讨论两个样本范围的结尾该如何组织可能性**。

### 最长回文子序列

给定一个字符串str，返回这个字符串的最长回文子序列长度

比如 ： str = “a12b3c43def2ghi1kpm”

最长回文子序列是“1234321”或者“123c321”，返回长度7

**分析**

是范围上的尝试模型，常常讨论范围的开头B和结尾E，两个可变参数结合的可能性：

1. 最长回文子序列的第一个字符不是B，有可能是E。（下）
2. 最长回文子序列的第一个字符不是E，有可能是B。（左）
3. 最长回文子序列的第一个字符不是B，也不是E。（左下）
4. 最长回文子序列的第一个字符是B，也是E。 B和E必须相同。（左下加2）

动态规划： 使用严格表结构

1. 两个可变参数B和E，取值范围为N-1，组成一个的二维数组存储每一个范围内的结果。

2. 从递归中分析依赖，一个位置的结果需要三个已算好的位置（左，左下，下）

3. 因为范围的开始位置不能小于结束位置，所以左下区域无效。

4. 先计算第一条对角线和第二天对角线，则之后的结果从下到上，每行的值都可以计算。 

5. **起始值为两条对角线** ，str1=“2bc2e”， 

   | **B\|E** | **0** | **1** | **2** | **3** | **4** |
   | -------- | ----- | ----- | ----- | ----- | ----- |
   | **0**    | 1     | 1     | 1     | 3     | 3     |
   | **1**    |       | 1     | 1     | 1     | 1     |
   | **2**    |       |       | 1     | 1     | 1     |
   | **3**    |       |       |       | 1     | 1     |
   | **4**    |       |       |       |       | 1     |

优化：剪枝

4中可能性中，结果是【左下+2，左，左下，下】的最大值。所以对于下一个位置的来说，它的左位置一定大于左下位置，所以可以减少一种可能性。不用和左下位置进行比较。

**发散思维**

给定String1，将其倒序生成String2，则String1和String2的最长公共子序列，就是String1的最长回文子序列。

因为回文的倒序和正序相同，所以可以将范围上的尝试模型，改为了样本对应的尝试模型。

**结论**

一个问题会有多种尝试搞出答案, 一定要会写尝试

### 象棋问题-马只走K步跳到指定位置的方法数

请同学们自行搜索或者想象一个象棋的棋盘，

然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置

那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域

给你三个 参数 x，y，k （**马走日**）

返回“马”从(0,0)位置出发，必须走完k步，最后落在(x,y)上的方法数有多少种? 

**分析**

如果位置依赖特别复杂, 就不改严格动态规划, 用傻缓存就行了

暴力尝试：

1. base case 当k=0, x=a,y=b时，返回1，否则返回0，表示之前尝试的步骤是无效的，此方法错误，不计入结果。
2. 马走日，所以每一步都有8个可以移动的位置。但注意棋盘的边界。
3. 取所有方法的和为结果。

动态规划：三维数组（行列层），每一步一层，同一层的位置没有相互依赖，都只依赖下一层。如第一步k依赖第二步k=k-1。

### 所有咖啡杯变干净的最早时间

数组arr代表每一个咖啡机冲一杯咖啡的时间，每个咖啡机只能串行的制造咖啡。

现在有n个人需要喝咖啡，只能用咖啡机来制造咖啡。

认为每个人喝咖啡的时间非常短，冲好的时间即是喝完的时间。

每个人喝完之后咖啡杯可以选择洗或者自然挥发干净，只有一台洗咖啡杯的机器，只能串行的洗咖啡杯。

洗杯子的机器洗完一个杯子时间为a，任何一个杯子自然挥发干净的时间为b。

假设时间点从0开始，返回所有人喝完咖啡并洗完咖啡杯的全部过程结束后，至少来到什么时间点。【返回从开始等到所有咖啡杯变干净的最短时间（京东面试题）】

**分析**

寻找业务限制的尝试模型，范围上尝试的模型：四个参数：int[] arr、int N，int a、int b

分解题意，有两个过程：

1. 所有人先在咖啡机前排队，获得**所有人的咖啡都做好的最短时间**。
2. 洗杯子或自然挥发，让所有**咖啡杯变干净的最短时间**

递归尝试：

1. 做咖啡的递归

   1. 参数：int[] arr、int N，int a、int b，**int[] time(每台咖啡机空闲的时刻)，int[] drink(每个人喝完咖啡的时刻)，index(第几个人)**

   2. base case : 当index==N时，所有人都喝完咖啡，对drink排序，并获取洗干净所有杯子的最短的时间。

   3. 每个人都尝试在每一台咖啡机前排队，取第index个人在每台咖啡机前排队花费的最少时间。

      需要设置time和drink的值，比较完结果后，要恢复现场数据，进行下一次的选择。

2. 洗杯子的递归：

   1. 参数：int[] drink，int a、int b，**int washline(洗杯机空闲时间)，int time(累计消耗的时间)，int index(第几个杯子)**

   2. base case: 当index=drink.lenth时，所有杯子都洗完，返回累计消耗的时间time。

   3. 每个杯子有两种方式，在洗杯机前排队，或自然挥发。

      每种方式花费的时间需要和上一次的累计时间time进行比较，最大值就是每种方式的累计消耗时间。

      washline是 喝完咖啡的时间和洗杯机空闲时间的最大值，再加上洗一次的时间。

   4. 返回两种方式下，杯子全部洗完的最小时间。

递归优化：

1. 做咖啡的递归：使用贪心策略，每个人在做完咖啡的时间最短的咖啡机前排队。

   使用小根堆，用泡咖啡花费的时间和咖啡机空闲的时刻组合排序，每个人获取最小值，并更新咖啡机的空闲时刻，排队完成，得到每个人泡完咖啡的时刻。（时刻就是从当前开始算，过多少小时才能完成任务）。

2. 洗杯子的递归，减少可变参数，去掉time(累计消耗的时间)，当前杯子洗完的时间和下一次杯子洗完的时间，取最大值，就是每种方式的累计消耗时间。

动态规划：

1. 分析可变参数，确定严格位置依赖的表范围。

2. 按可变参数的最大程度来统计，free（洗杯子机可以使用的时间）的无法明确范围大小，需要先根据业务逻辑计算free的最大值。

   **限制不够，业务来凑。**： 假设都用洗杯机洗，maxFree=drink[n-1]+wash.

3. 因为base case的条件包含N，maxFree的值也包含，dp=new int [n+1]\[maxFree+1]

4. 填表时，确认哪些位置不需要填，如越界问题：因为free<=maxFree, 所以dp\[index+1]\[free+wash\] 就会越界。

   因为maxFree是所有杯子用机器洗的最大总时间，没必要讨论N之前的洗杯子机的空闲时间会大于maxFree的情况，所以在N之前的真实的递归中不会调用到这个状态。表中不填数据。

   当0 - n-1都使用洗杯机，则free=maxFree，clean1=maxFree+wash>maxFree

5. 按递归逻辑分析依赖关系，是每一行都依赖下一行的数据。所以从下往上填数据。

6. **起始值为最后一行，都为0**



### 矩阵中的最小路径和

给定一个二维数组matrix，一个人必须从左上角出发，最后到达右下角

沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和

返回最小距离累加和



### 货币面值系列

#### 货币数组组成面值的方法数-同值认为不同 

arr是货币数组，其中的值都是正数。再给定一个正数aim。

每个值都认为是一张货币，即便是值相同的货币也认为每一张都是不同的，

从arr index出发及其后面所有货币自由选择, 组成正好aim这么多的钱有几种方法.

例如：arr = {1,1,1}，aim = 2

第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2，一共就3种方法，所以返回3。



#### 面值数组组成面值的方法数-张数不限

arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。

每个值都认为是一种面值，且认为张数是无限的。

从arr index出发及其后面所有的面值, 每一个面值都可以自由选择, 组成正好aim这么多的钱, 方法数是多少?

例如：arr = {1,2}，aim = 4

方法如下：1+1+1+1、1+1+2、2+2，一共就3种方法，所以返回3



#### 货币数组组成面值的方法数-同值无差别(张数限定)  

arr是货币数组，其中的值都是正数。再给定一个正数aim。

每个值都认为是一张货币，认为值相同的货币没有任何不同，

从arr index出发及其往后所有的面值在张数规定好的情况下组成aim的方法数。

例如：arr = {1,2,1,1,2,1,2}，aim = 4

方法：1+1+1+1、1+1+2、2+2，一共就3种方法，所以返回3




## 空间压缩的技巧

利用观察观察法对枚举行为做斜率优化  把枚举行为省下来

通过观察法: 发现临近的格子对我的枚举行为有加速

当你发现在推每一个格子的时候有枚举行为, 多一点观察,   

观察后可能能发现,你的枚举行为,可以被你的临近位置的值替代,   

属于动态规划中斜率优化的范畴

#### Bob生还的概率

给定5个参数，N，M，row，col，k

表示在N*M的区域上，醉汉Bob初始在(row,col)位置

Bob一共要迈出k步，且每步都会等概率向上下左右四个方向走一个单位

任何时候Bob只要离开N*M的区域，就直接死亡

返回k步之后，Bob还在N*M的区域的概率



题目1: [[英雄砍死怪兽的概率]]  
题目2: [[面值数组组成面值的最少货币数]]  
题目3: [[给定一个正整数n, 求裂开的方法数]]  



题目1: [[正数数组分割为累加和接近的两个集合]]    
题目2: [[正数数组分割为个数跟累加和接近的两个集合]]    