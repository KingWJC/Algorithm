# 暴力递归

暴力递归就是一个简单的递归尝试方法。 出现了一个问题，不知道是怎么解决的，但我们知道可以怎么一步一步进行尝试，在这一步步的尝试过程就可以把问题解决了。

尝试的方法，可以画决策图，也可以用黑盒思维：

1. 把问题转化为规模缩小了的同类问题的子问题
2. 规定**黑盒函数的含义**：包括输入，达到什么效果，遵循的限制条件。

2. 有明确的不需要继续进行递归的条件（base case不需要再分解问题）。

3. 有当得到了子问题的结果之后的决策过程，（如何使用黑盒函数）

4. 不记录每一个子问题的解

## 题目

熟悉什么叫**尝试**：

1. 打印n层汉诺塔从最左边移动到最右边的全部过程

2. 打印一个字符串的全部子序列（可以不连续）

   所有情况是一个二叉树，分支为是否包含当前顶点，如123.  1为顶点，2为1的子节点，3为2的子节点

3. 打印一个字符串的全部子序列，要求不要出现重复字面值的子序列

4. 打印一个字符串的全部排列（字符都要，但顺序不一样）

   深度优先遍历中的技巧：在方法决策需要原始数据时，恢复现场。

   两种方法：使用集合 或直接在字符串中交换位置。

5. 打印一个字符串的全部排列，要求不要出现重复的排列

   减支：提前减少分支，boolean[] visit=new boolean[256]

   过滤：Set。

6. 给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数。 如何实现? 

   揭示: 你想怎么试就能怎么写, 但必须保证子问题跟所描述的是一个事，一个大问题要拆成同样含义但数据量变小的子问题  

   但是, 尝试是有优劣的:  比如汉诺塔问题, 可以用6个递归  也可以做抽象化, 变成一个问题 

   重点是: 怎么设计一个尝试, 能够优化出最好版本  

# 动态规划

什么暴力递归可以继续优化？

1. 有重复调用同一个子问题的解，这种递归可以优化
2. 如果每一个子问题都是不同的解，无法优化也不用优化

暴力递归和动态规划的关系：

1. 某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划
2. 任何动态规划问题，都一定对应着某一个有重复过程的暴力递归
3. 但不是所有的暴力递归，都一定对应着动态规划

面试题和动态规划的关系：

1. 解决一个问题，可能有很多尝试方法
2. 可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式
3. 一个问题**可能有**若干种动态规划的解法

## 步骤

**在递归写法中，找出可变参数， 再找出依赖项，再找出这个动态规划表中我们想要的是哪一块。** 找出不需要依赖其他项的，先填，也就是先填递归到底的情况和边界情况。

![Pasted image 20210504190038](images\Pasted image 20210504190038.png)

如何找到某个问题的动态规划方式：

1. 设计暴力递归：**重要原则+4种常见尝试模型**！重点！

   1）从左往右的尝试模型

   2）范围上的尝试模型

   3）多样本位置全对应的尝试模型

   4）寻找业务限制的尝试模型

2. 分析有没有重复解：

   列出调用过程，可以只列出前几层，有没有重复解，一看便知。

3. 用记忆化搜索 -> 用严格表结构实现动态规划：套路解决

4. 看看能否继续优化：动态规划的进一步优化

   1）空间压缩

   2）状态化简

   3）四边形不等式

   4）其他优化技巧

**面试**中设计暴力递归过程的重要原则：

1. 每一个可变参数的类型，一定不要比int类型更加复杂
2. 原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数
3. 如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可
4. 可变参数的个数，能少则少

知道了面试中设计暴力递归过程的原则，然后：

1. 一定要逼自己找到不违反原则情况下的暴力尝试！
2. 如果你找到的暴力尝试，不符合原则，马上舍弃！找新的！
3. 如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%！

暴力递归到动态规划的套路

1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用

2）找到哪些参数的变化会影响返回值，对每一个列出变化范围

3）参数间的所有的组合数量，意味着表大小

4）记忆化搜索的方法就是傻缓存，非常容易得到

5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解

6）对于有枚举行为的决策过程，进一步优化

## 题目

1. 斐波那契数列 f(N)=f(N-1)+f(N-2); 求第N项的值，

   - 相当于高度N的二叉树，每个节点都返回值，才能得到顶部的值。
   - 尝试的暴力递归中有重复过程，可以加缓存进行优化。这个过程就是动态规划。
   - 加缓存和顺序计算，时间复杂度都是O(N)。

2. [[N皇后问题]]

   假设有排成一行的N个位置，记为1~N，N 一定大于或等于 2

   开始时机器人在其中的M位置上(M 一定是 1~N 中的一个)

   如果机器人来到1位置，那么下一步只能往右来到2位置；

   如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；

   如果机器人来到中间位置，那么下一步可以往左走或者往右走；

   规定机器人必须走 K 步，最终能来到P位置(P也是1~N中的一个)的方法有多少种

   给定四个参数 N、M、K、P，返回方法数。

   **分析**：方法数的数据：是一个有边界条件的二叉树。f(M ,K) = f(M-1 ,K-1) + f(M+1 ,K-1)

   尝试：使用暴力递归完成。

   优化：M，K能确认一个唯一的结果，所以使用二维缓存表，空间换时间，实现从顶向下的动态规划（也记忆化搜索）。

   **示例**：N: 1~5,  M起始位置: 2，P目标位置: 4，K: 6，填充方法数的二维缓存表

   | N位置(行) / K步 (列) |  0   |  1   |  2   |  3   |  4   |  5   |  6   |
   | :------------------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
   |        **1**         |  0   |  0   |  0   |  1   |  0   |  4   |  0   |
   |        **2**         |  0   |  0   |  1   |  0   |  4   |  0   |  13  |
   |        **3**         |  0   |  1   |  0   |  3   |  0   |  9   |  0   |
   |        **4**         |  1   |  0   |  2   |  0   |  5   |  0   |  14  |
   |        **5**         |  0   |  1   |  0   |  2   |  0   |  5   |  0   |

   当剩余步数K为0时，只有到达P: 4，则方法数为1.（base case)

   当当前位置M为1时，只能往位置N: 2的走，总是依赖于下一行2位置的K-1的数据，所以f(1 ,K) = f(2 , K-1)

   当当前位置M为5时，只能往位置N: 4的走，总是依赖于上一行2位置的K-1的数据，所以f(5 ,K) = f(4 , K-1)

   其它位置：依赖于左下加左上的值。f(M ,K) = f(M-1 ,K-1) + f(M+1 ,K-1)

   **结论**

   二维动态规划表（状态转移），翻转后会撞墙的杨辉三角形。

   动态规划是结果，不是原因。每次的递归尝试，分析位置依赖，尝试的策略就是状态转移的方程。

   尝试是自然智慧。

   实现：需要无效参数的总结。

2. 

从左往右的尝试模型

- [[数字转化为字符串的结果数]]
- [[背包能装下最多的价值]]

范围上尝试的模型

- [[A,B玩家从左右两边拿纸牌,返回最后获胜者的分数]]

  给定一个整型数组arr，代表数值不同的纸牌排成一条线

  玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿

  但是每个玩家每次只能拿走最左或最右的纸牌

  玩家A和玩家B都绝顶聪明，请返回最后获胜者的分数。 

-  
  
- [[多少张贴纸可以贴出给定字符串|贴纸拼词]]
- [[两个字符串的最长公共子序列]]

- [[最长回文子序列]] [M]   
  一个问题会有多种尝试搞出答案, 一定要会写尝试

- [[象棋问题-马只走K步跳到指定位置的方法数]]
  如果位置依赖特别复杂, 就不改严格动态规划, 用傻缓存就行了

- [[所有咖啡杯变干净的最早时间]]
  寻找业务限制的尝试模型

[[矩阵中的最小路径和]]

### 货币面值系列

货币数组组成面值的方法数-同值认为不同   请注意对比题目一

>从arr index出发及其后面所有货币自由选择, 组成正好rest这么多的钱有几种方法

[[面值数组组成面值的方法数-张数不限]]

>从arr index出发及其后面所有的面值, 每一个面值都可以自由选择, 组成正好rest这么多的钱, 方法数是多少?

[[货币数组组成面值的方法数-同值无差别(张数限定)]]    请注意对比题目三  

>从arr index出发及其往后所有的面值在张数规定好的情况下组成rest的方法数  
>[[货币数组面值的方法数-同值无差别(张数限定)-难点解释]]

### 动态规划中空间压缩的技巧

---

题目四: [[Bob生还的概率]]  



利用观察观察法对枚举行为做斜率优化  把枚举行为省下来

通过观察法: 发现临近的格子对我的枚举行为有加速

当你发现在推每一个格子的时候有枚举行为, 多一点观察,   
观察后可能能发现,你的枚举行为,可以被你的临近位置的值替代,   
属于动态规划中斜率优化的范畴

题目1: [[英雄砍死怪兽的概率]]  
题目2: [[面值数组组成面值的最少货币数]]  
题目3: [[给定一个正整数n, 求裂开的方法数]]  



题目1: [[正数数组分割为累加和接近的两个集合]]    
题目2: [[正数数组分割为个数跟累加和接近的两个集合]]    

## 