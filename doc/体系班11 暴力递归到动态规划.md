# 暴力递归

暴力递归就是一个简单的递归尝试方法。 出现了一个问题，不知道是怎么解决的，但我们知道可以怎么一步一步进行尝试，在这一步步的尝试过程就可以把问题解决了。

尝试的方法，可以画决策图，也可以用黑盒思维：

1. 把问题转化为规模缩小了的同类问题的子问题
2. 规定**黑盒函数的含义**：包括输入，达到什么效果，遵循的限制条件。

2. 有明确的不需要继续进行递归的条件（base case不需要再分解问题）。

3. 有当得到了子问题的结果之后的决策过程，（如何使用黑盒函数）

4. 不记录每一个子问题的解

## 题目

熟悉什么叫**尝试**：

1. 打印n层汉诺塔从最左边移动到最右边的全部过程

2. 打印一个字符串的全部子序列（可以不连续）

   所有情况是一个二叉树，分支为是否包含当前顶点，如123.  1为顶点，2为1的子节点，3为2的子节点

3. 打印一个字符串的全部子序列，要求不要出现重复字面值的子序列

4. 打印一个字符串的全部排列（字符都要，但顺序不一样）

   深度优先遍历中的技巧：在方法决策需要原始数据时，恢复现场。

   两种方法：使用集合 或直接在字符串中交换位置。

5. 打印一个字符串的全部排列，要求不要出现重复的排列

   减支：提前减少分支，boolean[] visit=new boolean[256]

   过滤：Set。

6. 给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数。 如何实现? 

   揭示: 你想怎么试就能怎么写, 但必须保证子问题跟所描述的是一个事，一个大问题要拆成同样含义但数据量变小的子问题  

   但是, 尝试是有优劣的:  比如汉诺塔问题, 可以用6个递归  也可以做抽象化, 变成一个问题 

   重点是: 怎么设计一个尝试, 能够优化出最好版本  

# 动态规划

## 定义

什么暴力递归可以继续优化？

1. 有重复调用同一个子问题的解，这种递归可以优化
2. 如果每一个子问题都是不同的解，无法优化也不用优化

暴力递归和动态规划的关系：

1. 某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划
2. 任何动态规划问题，都一定对应着某一个有重复过程的暴力递归
3. 但不是所有的暴力递归，都一定对应着动态规划

面试题和动态规划的关系：

1. 解决一个问题，可能有很多尝试方法
2. 可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式
3. 一个问题**可能有**若干种动态规划的解法

**暴力递归之所以暴力是因为有大量重复计算在浪费时间**

**动态规划就是某一类尝试行为的进一步优化，任何一个动态规划的问题都是以某一个暴力尝试过程中优化后的样子**

## 步骤

**在递归写法中，找出可变参数， 再找出依赖项，再找出这个动态规划表中我们想要的是哪一块。** 找出不需要依赖其他项的，先填，也就是先填递归到底的情况和边界情况。

![Pasted image 20210504190038](images\Pasted image 20210504190038.png)

如何找到某个问题的动态规划方式：

1. 设计暴力递归：**重要原则+4种常见尝试模型**！重点！

   1）从左往右的尝试模型

   2）范围上的尝试模型

   3）多样本位置全对应的尝试模型

   4）寻找业务限制的尝试模型

2. 分析有没有重复解：

   列出调用过程，可以只列出前几层，有没有重复解，一看便知。

3. 用记忆化搜索 -> 用严格表结构实现动态规划：套路解决

4. 看看能否继续优化：动态规划的进一步优化

   1）空间压缩

   2）状态化简

   3）四边形不等式

   4）其他优化技巧

**面试**中设计暴力递归过程的重要原则：

1. 每一个可变参数的类型，一定不要比int类型更加复杂
2. 原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数
3. 如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可
4. 可变参数的个数，能少则少

知道了面试中设计暴力递归过程的原则，然后：

1. 一定要逼自己找到不违反原则情况下的暴力尝试！
2. 如果你找到的暴力尝试，不符合原则，马上舍弃！找新的！
3. 如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%！

暴力递归到动态规划的套路

1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用

2）找到哪些参数的变化会影响返回值，对每一个列出变化范围

3）参数间的所有的组合数量，意味着表大小

4）记忆化搜索的方法就是傻缓存，非常容易得到

5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解

6）对于有枚举行为的决策过程，进一步优化

## 题目

### 斐波那契数列

 f(N)=f(N-1)+f(N-2); 求第N项的值，

- 相当于高度N的二叉树，每个节点都返回值，才能得到顶部的值。
- 尝试的暴力递归中有重复过程，可以加缓存进行优化。这个过程就是动态规划。
- 加缓存和顺序计算，时间复杂度都是O(N)。

### N皇后问题

假设有排成一行的N个位置，记为1~N，N 一定大于或等于 2

开始时机器人在其中的M位置上(M 一定是 1~N 中的一个)

如果机器人来到1位置，那么下一步只能往右来到2位置；

如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；

如果机器人来到中间位置，那么下一步可以往左走或者往右走；

规定机器人必须走 K 步，最终能来到P位置(P也是1~N中的一个)的方法有多少种

给定四个参数 N、M、K、P，返回方法数。

**分析**：方法数的数据：是一个有边界条件的二叉树。f(M ,K) = f(M-1 ,K-1) + f(M+1 ,K-1)

尝试：使用暴力递归完成。

优化：M，K能确认一个唯一的结果，所以使用二维缓存表，空间换时间，实现从顶向下的动态规划。

暴力递归中有重复计算，给其加缓存，下回遇到同样一个过程，直接从缓存中拿结果。 也叫**记忆化搜索（动态规划中最糙的一种，不关心状态的依赖）**

**示例**：N: 1~5,  M起始位置: 2，P目标位置: 4，K: 6，填充方法数的二维缓存表

| N位置(行) / K步 (列) |  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :------------------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|        **1**         |  0   |  0   |  0   |  1   |  0   |  4   |  0   |
|        **2**         |  0   |  0   |  1   |  0   |  4   |  0   |  13  |
|        **3**         |  0   |  1   |  0   |  3   |  0   |  9   |  0   |
|        **4**         |  1   |  0   |  2   |  0   |  5   |  0   |  14  |
|        **5**         |  0   |  1   |  0   |  2   |  0   |  5   |  0   |

当剩余步数K为0时，只有到达P: 4，则方法数为1.（base case)

当当前位置M为1时，只能往位置N: 2的走，总是依赖于下一行2位置的K-1的数据，所以f(1 ,K) = f(2 , K-1)

当当前位置M为5时，只能往位置N: 4的走，总是依赖于上一行2位置的K-1的数据，所以f(5 ,K) = f(4 , K-1)

其它位置：依赖于左下加左上的值。f(M ,K) = f(M-1 ,K-1) + f(M+1 ,K-1)

**结论**

二维动态规划表（状态转移），翻转后是一个会撞墙的杨辉三角形。

动态规划是结果，不是原因。每次的递归尝试，分析位置依赖，尝试的策略就是状态转移的方程。

尝试是自然智慧。是**范围上尝试的模型**。

实现：需要无效参数的总结。

### A,B玩家从左右两边拿纸牌,返回最后获胜者的分数

给定一个整型数组arr，代表数值不同的纸牌排成一条线

玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿

但是每个玩家每次只能拿走最左或最右的纸牌

玩家A和玩家B都绝顶聪明，请返回最后获胜者的分数。 

**分析：**AB同样聪明，每次选择都是最优的决策。

**A作为先手**，在arr的L到R上拿牌，获得最好分数的**决策**如下：

​		base case L==R  arr[L]直接拿走。

​		若拿走左侧的牌arr[L]，然后轮到后手在L+1到R上，获取最好的分数。

​		若拿走右侧的牌arr[R]，然后轮到后手在L到R-1上，获取最好的分数

​		选择两次结果的最大值返回。

**A作为后手**：在arr的L到R上拿牌，获得最好分数的**决策**如下：

​		base case L==R  **arr[L]会被B拿走**，只能拿到0。

​		若左侧的牌arr[L]被B拿走，然后轮到先手在L+1到R上，获取最好的分数。

​		若右侧的牌arr[R]被B拿走，然后轮到先手在L到R-1上，获取最好的分数

​		选择两次结果的最小值返回。  因为**B作为先手会把最大的拿走，只会剩下最小的**。

优化1： f(0,7) -> g(1,7)  &  g(0,6) ->  { f(1,6)  &  f(2,7) }  &  { f(1,6)  & f(0,5) }  

​			如上所示， f(1,6) 的计算重复，使用记忆化搜索。 两个二维表，记录先手，后手的分数。

优化2：用严格表结构实现动态规划

**示例**

[50，100，20，10]，只能从左或右选择一张牌

先手：10，100；后手：50，20。 获胜者的分数是110.

[7，4，16，15，1] 的先手，后手，在L到R上的最好分数，的二维动态规划表。

| (先手）L/R | 0    | 1    | 2    | 3    | 4    |
| :--------: | ---- | ---- | ---- | ---- | ---- |
|   **0**    | 7    | 7    | 20   | 23   | 24   |
|   **1**    | X    | 4    | 16   | 19   | 19   |
|   **2**    | X    | X    | 16   | 16   | 17   |
|   **3**    | X    | X    | X    | 15   | 15   |
|   **4**    | X    | X    | X    | X    | 1    |

| （后手）L/R | 0    | 1    | 2    | 3    | 4    |
| :---------: | ---- | ---- | ---- | ---- | ---- |
|    **0**    | 0    | 4    | 7    | 19   | 19   |
|    **1**    | X    | 0    | 4    | 16   | 17   |
|    **2**    | X    | X    | 0    | 15   | 15   |
|    **3**    | X    | X    | X    | 0    | 1    |
|    **4**    | X    | X    | X    | X    | 0    |

1. 对角线表示只剩一张牌，先手的对角线是当前位置的值，后手的对角线是0.

2. L不能小于R，所以表格下半部分都是X。

3. 按对角线的上一条线，进行填充值。先手表的值需要在后手表中，找对称点，然后L位置的值加上对称点下边的值，R位置的值加上对称点前面的值， 取最大值。

   dpf  = Math.max( arr[L]+dpg\[L+1\]\[R\],  arr[R]+dpg\[L\]\[R-1\] )

   dpg = Math.min( dpf\[L+1\]\[R\],  dpf\[L\]\[R-1\] )

4. **后手的计算，不需要加arr[L]或arr[R], 因为已被对手拿走**

**结论：**

属于**零和博弈**又称“*零和*游戏”，是博弈论的一个概念，属非合作*博弈*，指参*与博弈*的各方，在严格竞争下，一方的收益必然意味着另一方的损失，博弈各方的收益和损失相加总和永远为“零”。

尝试策略和状态转移方程是一回事。

是**范围上尝试的模型**。



从左往右的尝试模型

- [[数字转化为字符串的结果数]]
- [[背包能装下最多的价值]]

范围上尝试的模型

- [[多少张贴纸可以贴出给定字符串|贴纸拼词]]
- [[两个字符串的最长公共子序列]]

- [[最长回文子序列]] [M]   
  一个问题会有多种尝试搞出答案, 一定要会写尝试

- [[象棋问题-马只走K步跳到指定位置的方法数]]
  如果位置依赖特别复杂, 就不改严格动态规划, 用傻缓存就行了

- [[所有咖啡杯变干净的最早时间]]
  寻找业务限制的尝试模型

[[矩阵中的最小路径和]]

### 货币面值系列

货币数组组成面值的方法数-同值认为不同   请注意对比题目一

>从arr index出发及其后面所有货币自由选择, 组成正好rest这么多的钱有几种方法

[[面值数组组成面值的方法数-张数不限]]

>从arr index出发及其后面所有的面值, 每一个面值都可以自由选择, 组成正好rest这么多的钱, 方法数是多少?

[[货币数组组成面值的方法数-同值无差别(张数限定)]]    请注意对比题目三  

>从arr index出发及其往后所有的面值在张数规定好的情况下组成rest的方法数  
>[[货币数组面值的方法数-同值无差别(张数限定)-难点解释]]

### 动态规划中空间压缩的技巧

---

题目四: [[Bob生还的概率]]  



利用观察观察法对枚举行为做斜率优化  把枚举行为省下来

通过观察法: 发现临近的格子对我的枚举行为有加速

当你发现在推每一个格子的时候有枚举行为, 多一点观察,   
观察后可能能发现,你的枚举行为,可以被你的临近位置的值替代,   
属于动态规划中斜率优化的范畴

题目1: [[英雄砍死怪兽的概率]]  
题目2: [[面值数组组成面值的最少货币数]]  
题目3: [[给定一个正整数n, 求裂开的方法数]]  



题目1: [[正数数组分割为累加和接近的两个集合]]    
题目2: [[正数数组分割为个数跟累加和接近的两个集合]]    

## 