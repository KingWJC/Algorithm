# 回文

假设字符串str长度为N，想返回最长回文子串（**连续**）的长度，

回文：字符串中间有对称轴，两边是镜像(逆序)，成对称性，如奇数：”12321“ 偶数：“123321”

回文的作用：DNA序列。回文字符串有其独特的生理学意义。人体的对称。

## 暴力解

递归函数：以某一个位置为中心点，若两边相同则外扩，直到无法外扩，返回最后生成的字符串的长度。

示例：aba12321ac

当中心点为位置0的a时，字符串为"a" ,返回1

当中心点为位置1的b时，字符串为"aba" ,返回3

当中心点为位置2的a时，字符串为"a" ,返回1

缺点是无法解决偶数回文的问题，因为偶数字符串的回文在虚轴上。

**解决办法**

处理原始字符串，在每个字符的前后加特殊字符：#a#b#a#1#2#3#2#1#a#c#

如果字符串为奇数，则加上的特殊字符是偶数，结果还是奇数。

如果字符串为偶数，则加上的特殊字符是奇数，结果还是奇数。 长度变为2N+1

再使用上面的方法，结果/2，就是原始串的答案。

如果不用特殊字符#，而使用原始串中的字符串，不会对结果产生影响。因为比较的时候不会出现虚的字符和实字符比较的情况。

通过处理串的位置X，对应到原始串的位置Y： Y=(X-1)/2

**时间复杂度估算：**

先举最差例子：全是a： aaaaa，处理后是 #a#a#a#a#a#a#, 每个位置扩展的次数是：01234543210，累加为25

所以时间复杂度是O(N^2)

慢的原因：每个位置的扩大事件都是独立的，前面扩充后的结果，不能指导从后面位置出发往左右两端扩的行为。

# 定义

Manachar算法，就是找最长回文子串，最快的算法

前面扩的行为会加速后面扩的行为。

时间复杂度是线性的O(N)

## 概念

1. 回文直径，回文半径：

   12321，直径是5 半径是3；1221，直径是4 半径是2

2. 回文半径数组

   每个位置往左右两边扩的结果的半径，记录到数组中。

   回文半径数组radius是用来记录以每个位置的字符为回文中心求出的回文半径长度。

   对于p1所指的位置radius[6]的回文半径是5。

   ![img](images/12738509-29660a214405b83b)

3. 最右回文的右边界R int

   若每个位置处理后，回文的边界更靠右了，则用R记录回文的右边界，开始R=-1，因为0位置还没有扩

   一个位置的最右回文右边界指的是：这个位置及之前的位置的回文子串，所到达的最右边的地方。

4. 取得回文最右边界时，中心C是哪个位置。

   就是R进行更新的时候，记录当时回文的中心位置。

   示例：#1#1#2#1#1#k.......

   当0位置处理后，回文区域是0-0，比R大，变得更右，所以R=0，C=0

   当1位置处理后，回文区域是#1#，比R大，变得更右，所以R=2，C=1

   当2位置处理后，回文区域是#1#1#，比R大，变得更右，所以R=4，C=2

   当3位置处理后，回文区域是#1#，区域没有更右，所以R和C都不变，R=4，C=2

## 过程

当从index位置，往左右两边扩，会有如下几种情况

1. index没有被R罩住，当index==0或1.....

   没法优化，暴力解。

2. index被R罩住的情况 index<=R

   必定存在一下的拓扑关系：L......index"......C......index.......R。 index通过中心C肯定有对称点index"。

   1. index"扩出的回文区域在【L，R】内。O(1)

      示例：(L)a b【c **d(index")** c】ks **t(C)** skc **d(index)** cb a(R)中，index”的回文区域 [cdc] 在【L，R】内。

      则index的回文一定和index"的一样。

      **证明**：因为index和index“以中心C对称，所以index"的回文区域**甲**，是index的回文区域**乙**的逆序，所以index的回文区域至少是index"的回文区域那么大。

      假设甲的前后位置是a和b，a不等于b，乙的前后位置是x和y。因为对称，所以b\==x，a\==y，所以x不等于y。

   2. index"扩出的回文区域在【L，R】外。O(1)

      示例：【ab**(L)**cd **e(index")** dcba】t **s(C)** tabcd **e(index)** dc**(R)**f中，index”的回文区域 [abcdedcba] 在【L，R】外。

      则index的回文区域，是以index到R的长度为回文半径。【cdedc】。

      **证明**：以index"为中心，找到L的对称点L"，则【L，L"】为区域**甲**，以index为中心，找到R的对称点R"，则【R，R"】为区域**乙**，

      甲因为在index”的回文区域里，所以一定是回文，

      因为index和index“以中心C对称，甲和乙是逆序关系，乙也一定是回文。

      为什么不能再扩出更长，假设甲的前后位置是a和b，因为甲在index"的回文里，所以**a\==b**，乙的前后位置是x和y。x与b关于c对称，所以**x==b**。

      因为a>L，以C为中心是没有往外扩，所以$a\neq y$，所以$x\neq y$，乙不能再外扩

   3. index"扩出的回文区域与【L，R】的L重合。

      示例：X【**(L)**ab **c(index")** ba】s **t(C)** sab **c(index)** ba**(R)**S中，index”的回文区域 [abcba] 与【L，R】的L重合。

      则index的回文区域至少会和index"的一样大。

      但也可能会更大，需要去对比这个回文区域的左右两个字符是否相等。

## 时间复杂度

失败几次：每个位置为中心往外扩，必会失败一次（到边界），总共失败N次。

成功几次：

1. 当index在R外时，暴力扩，R会更新，上升变大。
2. 当index在R内时，
   1. index"在【L，R】内，O(1)，不用分析
   2. index"在【L，R】外，O(1，不用分析
   3. index“和L重合。
      1. index-R之间是不验的，从R+1
      2. 若失败，则执行一次。若成功，R更新，上升变大。R的变化范围从0~N
      3. R不会回退，直到最大值N，所以整个过程O(N)

# 算法核心

1）理解回文半径数组  

2）理解所有中心的回文最右边界R，和取得R时的中心点C  

3）理解   L…(i')…C…(i)…R  的结构，以及根据i'回文长度进行的状况划分  

4）每一种情况划分，都可以加速求解i回文半径的过程  

# 题目

## 字符串变为回文需要添加的最少字符

示例：abc12321，最少添加3个字符cba。

实质是求，必须包含最后一个字符的情况下，最长回文串，将这个回文子串之前的字符串逆序，再加上就可以。

使用manacher算法，每个位置计算回文范围，如果以一个位置为中心，其回文范围右边界覆盖字符串的右边界，则它是最早的能把字符串终止位置覆盖的中心位置。

返回最终的字符串。